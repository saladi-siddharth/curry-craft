import React, { useState, useEffect, useRef, useCallback } from 'react';

// Firebase Imports
import { initializeApp } from 'firebase/app';
import {
  getAuth,
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  signInWithPhoneNumber,
  RecaptchaVerifier,
  GoogleAuthProvider, // Import GoogleAuthProvider
  signInWithPopup,
  signInWithCustomToken, // Import signInWithCustomToken
  signInAnonymously // Import signInAnonymously
} from 'firebase/auth';
import {
  getFirestore,
  doc,
  setDoc,
  getDoc,
  updateDoc,
  arrayUnion,
  arrayRemove
} from 'firebase/firestore';

// YOUR SPOONACULAR API KEY
// IMPORTANT: For production deployment, consider moving this API key to a server-side proxy
// or environment variables to prevent client-side exposure.
const SPOONACULAR_API_KEY = '96d9cb981707407ebcf670ed5134907a';

// Gemini API Key (left empty as per instructions for Canvas runtime injection)
const GEMINI_API_KEY = ""; // Canvas will provide this at runtime

// Screen names for navigation
const SCREENS = {
  LOGIN: 'login',
  SIGNUP: 'signup',
  PHONE_LOGIN: 'phone_login',
  HOME: 'home',
  RECIPE_LIST: 'recipe_list',
  RECIPE_DETAIL: 'recipe_detail',
  PROCEDURE: 'procedure',
  COMPLETED: 'completed',
  SETTINGS: 'settings', // New settings screen
};

// Translations for static UI text
const translations = {
  en: {
    welcomeBack: "Welcome Back!",
    createAccount: "Create Account",
    loginWithPhone: "Login with Phone",
    loginWithGoogle: "Login with Google", // New translation key
    email: "Email",
    password: "Password",
    loginWithEmail: "Login with Email",
    dontHaveAccount: "Don't have an account?",
    signUp: "Sign Up",
    alreadyHaveAccount: "Already have an account?",
    backToEmailLogin: "Back to Email Login",
    enterPhoneNumber: "Enter phone number (e.g., +1234567890)",
    sendOtp: "Send OTP",
    enterVerificationCode: "Enter verification code", // Used for placeholder
    verifyOtp: "Verify OTP",
    otpSent: "OTP sent to your phone!",
    whatsInKitchen: "What's in your kitchen?",
    enterIngredient: "Enter ingredient (e.g., 'chicken', 'rice')",
    addIngredient: "Add Ingredient",
    yourIngredients: "Your Ingredients:",
    clearAll: "Clear All",
    selectCuisine: "Select Cuisine (Optional):",
    anyCuisine: "Any Cuisine",
    findRecipes: "Find Recipes",
    recommendedRecipes: "Recommended Recipes",
    backToIngredients: "Back to Ingredients",
    ingredients: "Ingredients",
    description: "Description",
    startCookingProcedure: "Start Cooking Procedure",
    copyRecipe: "Copy Recipe",
    copied: "Copied!",
    cookingProcedure: "Cooking Procedure",
    step: "Step",
    previousStep: "Previous Step",
    nextStep: "Next Step",
    finishCooking: "Finish Cooking!",
    congratulations: "ЁЯОЙ Congratulations! ЁЯОЙ",
    recipeCompleted: "You've successfully completed the recipe:",
    cookAnotherRecipe: "Cook Another Recipe",
    logout: "Logout",
    loadingApp: "Loading app...",
    error: "Error:",
    pleaseAddIngredient: "Please add at least one ingredient to find recipes.",
    failedToFetchRecipes: "Failed to fetch recipes:",
    noRecipesFound: "No recipes found for your ingredients and cuisine. Try adding more or changing the cuisine!",
    settings: "Settings",
    language: "Language",
    popularDishes: "Popular Dishes",
    viewPopularDishes: "View Popular Dishes",
    backToHome: "Back to Home",
    noInstructions: "No detailed instructions available for this recipe.",
    failedToLoadUserData: "Failed to load user data. Please try again.",
    failedToSaveIngredient: "Failed to save ingredient to the cloud. Please try again.",
    failedToRemoveIngredient: "Failed to remove ingredient from the cloud. Please try again.",
    failedToClearIngredients: "Failed to clear ingredients in the cloud. Please try again.",
    securityCheckNotReady: "Security check not ready. Please try again.",
    firebaseAuthNotInitialized: "Firebase Auth not initialized.",
    pleaseSendOtpFirst: "Please send OTP first.",
    enterVerificationCodeError: "Please enter the verification code.", // Used for error message
    otpExpired: "Recaptcha expired. Please try sending OTP again.",
    failedToLoadSecurity: "Failed to load security check. Please refresh.",
    failedToInitAuth: "Failed to initialize authentication. Please check your Firebase config.",
    translatingContent: "Translating content",
    yourDish: "Your Dish",
    addSomeIngredients: "Add some ingredients to get started!",
    noDescription: "No description available.",
    recipe: "Recipe",
    backToRecipes: "Back to Recipes",
    defaultCuisine: "Default Cuisine", // New translation key
    backToDetails: "Back to Details", // New translation for procedure screen
    substitute: "Substitute", // New translation key
    ingredientSubstitutions: "Ingredient Substitutions for", // New translation key
    creativeRecipeIdea: "Creative Recipe Idea", // New translation key
    generateCreativeIdea: "Generate Creative Idea", // New translation key
    recipeName: "Recipe Name", // New translation key
    keyIngredients: "Key Ingredients", // New translation key
    close: "Close", // New translation key
    generatingIdea: "Generating idea...", // New translation key
    findingSubstitutions: "Finding substitutions...", // New translation key
    shortProcedure: "Short Procedure", // New translation key
    noIdeaGenerated: "No idea generated.", // New translation key
    noSuggestionsFound: "No suggestions found.", // New translation key
  },
  hi: { // Hindi
    welcomeBack: "рд╡рд╛рдкрд╕ рд╕реНрд╡рд╛рдЧрдд рд╣реИ!",
    createAccount: "рдЦрд╛рддрд╛ рдмрдирд╛рдПрдВ",
    loginWithPhone: "рдлреЛрди рд╕реЗ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВ",
    loginWithGoogle: "рдЧреВрдЧрд▓ рд╕реЗ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВ", // New translation key
    email: "рдИрдореЗрд▓",
    password: "рдкрд╛рд╕рд╡рд░реНрдб",
    loginWithEmail: "рдИрдореЗрд▓ рд╕реЗ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВ",
    dontHaveAccount: "рдЦрд╛рддрд╛ рдирд╣реАрдВ рд╣реИ?",
    signUp: "рд╕рд╛рдЗрди рдЕрдк рдХрд░реЗрдВ",
    alreadyHaveAccount: "рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдЦрд╛рддрд╛ рд╣реИ?",
    backToEmailLogin: "рдИрдореЗрд▓ рд▓реЙрдЧрд┐рди рдкрд░ рд╡рд╛рдкрд╕",
    enterPhoneNumber: "рдлреЛрди рдирдВрдмрд░ рджрд░реНрдЬ рдХрд░реЗрдВ (рдЙрджрд╛рд╣рд░рдг: +919876543210)",
    sendOtp: "рдУрдЯреАрдкреА рднреЗрдЬреЗрдВ",
    enterVerificationCode: "рд╕рддреНрдпрд╛рдкрди рдХреЛрдб рджрд░реНрдЬ рдХрд░реЗрдВ", // Used for placeholder
    verifyOtp: "рдУрдЯреАрдкреА рд╕рддреНрдпрд╛рдкрд┐рдд рдХрд░реЗрдВ",
    otpSent: "рдЖрдкрдХреЗ рдлреЛрди рдкрд░ рдУрдЯреАрдкреА рднреЗрдЬрд╛ рдЧрдпрд╛ рд╣реИ!",
    whatsInKitchen: "рдЖрдкрдХреЗ рд░рд╕реЛрдИ рдореЗрдВ рдХреНрдпрд╛ рд╣реИ?",
    enterIngredient: "рд╕рд╛рдордЧреНрд░реА рджрд░реНрдЬ рдХрд░реЗрдВ (рдЙрджрд╛рд╣рд░рдг: 'рдЪрд┐рдХрди', 'рдЪрд╛рд╡рд▓')",
    addIngredient: "рд╕рд╛рдордЧреНрд░реА рдЬреЛрдбрд╝реЗрдВ",
    yourIngredients: "рдЖрдкрдХреА рд╕рд╛рдордЧреНрд░реА:",
    clearAll: "рд╕рднреА рд╕рд╛рдл рдХрд░реЗрдВ",
    selectCuisine: "рд╡реНрдпрдВрдЬрди рдЪреБрдиреЗрдВ (рд╡реИрдХрд▓реНрдкрд┐рдХ):",
    anyCuisine: "рдХреЛрдИ рднреА рд╡реНрдпрдВрдЬрди",
    findRecipes: "рд░реЗрд╕рд┐рдкреА рдЦреЛрдЬреЗрдВ",
    recommendedRecipes: "рдЕрдиреБрд╢рдВрд╕рд┐рдд рд╡реНрдпрдВрдЬрди",
    backToIngredients: "рд╕рд╛рдордЧреНрд░реА рдкрд░ рд╡рд╛рдкрд╕",
    ingredients: "рд╕рд╛рдордЧреНрд░реА",
    description: "рд╡рд┐рд╡рд░рдг",
    startCookingProcedure: "рдЦрд╛рдирд╛ рдкрдХрд╛рдиреЗ рдХреА рд╡рд┐рдзрд┐ рд╢реБрд░реВ рдХрд░реЗрдВ",
    copyRecipe: "рд░реЗрд╕рд┐рдкреА рдХреЙрдкреА рдХрд░реЗрдВ",
    copied: "рдХреЙрдкреА рдХрд┐рдпрд╛ рдЧрдпрд╛!",
    cookingProcedure: "рдЦрд╛рдирд╛ рдкрдХрд╛рдиреЗ рдХреА рд╡рд┐рдзрд┐",
    step: "рдЪрд░рдг",
    previousStep: "рдкрд┐рдЫрд▓рд╛ рдЪрд░рдг",
    nextStep: "рдЕрдЧрд▓рд╛ рдЪрд░рдг",
    finishCooking: "рдЦрд╛рдирд╛ рдкрдХрд╛рдирд╛ рд╕рдорд╛рдкреНрдд рдХрд░реЗрдВ!",
    congratulations: "ЁЯОЙ рдмрдзрд╛рдИ рд╣реЛ! ЁЯОЙ",
    recipeCompleted: "рдЖрдкрдиреЗ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд░реЗрд╕рд┐рдкреА рдкреВрд░реА рдХрд░ рд▓реА рд╣реИ:",
    cookAnotherRecipe: "рдПрдХ рдФрд░ рд░реЗрд╕рд┐рдкреА рдмрдирд╛рдПрдВ",
    logout: "рд▓реЙрдЧ рдЖрдЙрдЯ",
    loadingApp: "рдРрдк рд▓реЛрдб рд╣реЛ рд░рд╣рд╛ рд╣реИ...",
    error: "рддреНрд░реБрдЯрд┐:",
    pleaseAddIngredient: "рд░реЗрд╕рд┐рдкреА рдЦреЛрдЬрдиреЗ рдХреЗ рд▓рд┐рдП рдХреГрдкрдпрд╛ рдХрдо рд╕реЗ рдХрдо рдПрдХ рд╕рд╛рдордЧреНрд░реА рдЬреЛрдбрд╝реЗрдВред",
    failedToFetchRecipes: "рд░реЗрд╕рд┐рдкреА рд▓рд╛рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓:",
    noRecipesFound: "рдЖрдкрдХреА рд╕рд╛рдордЧреНрд░реА рдФрд░ рд╡реНрдпрдВрдЬрди рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд░реЗрд╕рд┐рдкреА рдирд╣реАрдВ рдорд┐рд▓реАред рдЕрдзрд┐рдХ рдЬреЛрдбрд╝реЗрдВ рдпрд╛ рд╡реНрдпрдВрдЬрди рдмрджрд▓реЗрдВ!",
    settings: "рд╕реЗрдЯрд┐рдВрдЧреНрд╕",
    language: "рднрд╛рд╖рд╛",
    popularDishes: "рд▓реЛрдХрдкреНрд░рд┐рдп рд╡реНрдпрдВрдЬрди",
    viewPopularDishes: "рд▓реЛрдХрдкреНрд░рд┐рдп рд╡реНрдпрдВрдЬрди рджреЗрдЦреЗрдВ",
    backToHome: "рд╣реЛрдо рдкрд░ рд╡рд╛рдкрд╕",
    noInstructions: "рдЗрд╕ рд░реЗрд╕рд┐рдкреА рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╡рд┐рд╕реНрддреГрдд рдирд┐рд░реНрджреЗрд╢ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИрдВред",
    failedToLoadUserData: "рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдбреЗрдЯрд╛ рд▓реЛрдб рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    failedToSaveIngredient: "рд╕рд╛рдордЧреНрд░реА рдХреЛ рдХреНрд▓рд╛рдЙрдб рдкрд░ рд╕рд╣реЗрдЬрдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    failedToRemoveIngredient: "рд╕рд╛рдордЧреНрд░реА рдХреЛ рдХреНрд▓рд╛рдЙрдб рд╕реЗ рд╣рдЯрд╛рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    failedToClearIngredients: "рдХреНрд▓рд╛рдЙрдб рдореЗрдВ рд╕рд╛рдордЧреНрд░реА рд╕рд╛рдлрд╝ рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    securityCheckNotReady: "рд╕реБрд░рдХреНрд╖рд╛ рдЬрд╛рдВрдЪ рддреИрдпрд╛рд░ рдирд╣реАрдВ рд╣реИред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    firebaseAuthNotInitialized: "рдлрд╛рдпрд░рдмреЗрд╕ рдкреНрд░рдорд╛рдгреАрдХрд░рдг рдкреНрд░рд╛рд░рдВрдн рдирд╣реАрдВ рд╣реБрдЖред",
    pleaseSendOtpFirst: "рдХреГрдкрдпрд╛ рдкрд╣рд▓реЗ рдУрдЯреАрдкреА рднреЗрдЬреЗрдВред",
    enterVerificationCodeError: "рдХреГрдкрдпрд╛ рд╕рддреНрдпрд╛рдкрди рдХреЛрдб рджрд░реНрдЬ рдХрд░реЗрдВред", // Used for error message
    otpExpired: "рд░рд┐рдХреИрдкреНрдЪрд╛ рд╕рдорд╛рдкреНрдд рд╣реЛ рдЧрдпрд╛ред рдХреГрдкрдпрд╛ рдУрдЯреАрдкреА рджреЛрдмрд╛рд░рд╛ рднреЗрдЬрдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
    failedToLoadSecurity: "рд╕реБрд░рдХреНрд╖рд╛ рдЬрд╛рдВрдЪ рд▓реЛрдб рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рд░реАрдлреНрд░реЗрд╢ рдХрд░реЗрдВред",
    failedToInitAuth: "рдкреНрд░рдорд╛рдгреАрдХрд░рдг рдкреНрд░рд╛рд░рдВрдн рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рдХреГрдкрдпрд╛ рдЕрдкрдиреА рдлрд╛рдпрд░рдмреЗрд╕ рдХреЙрдиреНрдлрд╝рд┐рдЧрд░реЗрд╢рди рдЬрд╛рдВрдЪреЗрдВуАВ",
    translatingContent: "рд╕рд╛рдордЧреНрд░реА рдХрд╛ рдЕрдиреБрд╡рд╛рдж рд╣реЛ рд░рд╣рд╛ рд╣реИ",
    yourDish: "рдЖрдкрдХрд╛ рд╡реНрдпрдВрдЬрди",
    addSomeIngredients: "рд╢реБрд░реВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреБрдЫ рд╕рд╛рдордЧреНрд░реА рдЬреЛрдбрд╝реЗрдВ!",
    noDescription: "рдЗрд╕ рд░реЗрд╕рд┐рдкреА рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╡рд┐рд╡рд░рдг рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИред",
    recipe: "рд░реЗрд╕рд┐рдкреА",
    backToRecipes: "рд░реЗрд╕рд┐рдкреА рдкрд░ рд╡рд╛рдкрд╕",
    defaultCuisine: "рдбрд┐рдлрд╝реЙрд▓реНрдЯ рд╡реНрдпрдВрдЬрди", // New translation key
    backToDetails: "рд╡рд┐рд╡рд░рдг рдкрд░ рд╡рд╛рдкрд╕", // New translation for procedure screen
    substitute: "рдмрджрд▓реЗрдВ", // New translation key
    ingredientSubstitutions: "рд╕рд╛рдордЧреНрд░реА рдХреЗ рд╡рд┐рдХрд▓реНрдк", // New translation key
    creativeRecipeIdea: "рд░рдЪрдирд╛рддреНрдордХ рд░реЗрд╕рд┐рдкреА рд╡рд┐рдЪрд╛рд░", // New translation key
    generateCreativeIdea: "рд░рдЪрдирд╛рддреНрдордХ рд╡рд┐рдЪрд╛рд░ рдЙрддреНрдкрдиреНрди рдХрд░реЗрдВ", // New translation key
    recipeName: "рд░реЗрд╕рд┐рдкреА рдХрд╛ рдирд╛рдо", // New translation key
    keyIngredients: "рдореБрдЦреНрдп рд╕рд╛рдордЧреНрд░реА", // New translation key
    close: "рдмрдВрдж рдХрд░реЗрдВ", // New translation key
    generatingIdea: "рд╡рд┐рдЪрд╛рд░ рдЙрддреНрдкрдиреНрди рд╣реЛ рд░рд╣рд╛ рд╣реИ...", // New translation key
    findingSubstitutions: "рд╡рд┐рдХрд▓реНрдк рдЦреЛрдЬреЗ рдЬрд╛ рд░рд╣реЗ рд╣реИрдВ...", // New translation key
    shortProcedure: "рд╕рдВрдХреНрд╖рд┐рдкреНрдд рд╡рд┐рдзрд┐", // New translation key
    noIdeaGenerated: "рдХреЛрдИ рд╡рд┐рдЪрд╛рд░ рдЙрддреНрдкрдиреНрди рдирд╣реАрдВ рд╣реБрдЖред", // New translation key
    noSuggestionsFound: "рдХреЛрдИ рд╕реБрдЭрд╛рд╡ рдирд╣реАрдВ рдорд┐рд▓рд╛ред", // New translation key
  },
  kn: { // Kannada
    welcomeBack: "р▓ор▓░р▓│р▓┐ р▓╕р│Нр▓╡р▓╛р▓Чр▓д!",
    createAccount: "р▓Цр▓╛р▓др│Ж р▓░р▓Ър▓┐р▓╕р▓┐",
    loginWithPhone: "р▓лр│Лр▓ир│Н р▓ор│Вр▓▓р▓Х р▓▓р▓╛р▓Чр▓┐р▓ир│Н р▓ор▓╛р▓бр▓┐",
    loginWithGoogle: "р▓Чр│Вр▓Чр▓▓р│Н р▓ор│Вр▓▓р▓Х р▓▓р▓╛р▓Чр▓┐р▓ир│Н р▓ор▓╛р▓бр▓┐", // New translation key
    email: "р▓Зр▓ор│Зр▓▓р│Н",
    password: "р▓кр▓╛р▓╕р│Нр▓╡р▓░р│Нр▓бр│Н",
    loginWithEmail: "р▓Зр▓ор│Зр▓▓р│Н р▓ор│Вр▓▓р▓Х р▓▓р▓╛р▓Чр▓┐р▓ир│Н р▓ор▓╛р▓бр▓┐",
    dontHaveAccount: "р▓Цр▓╛р▓др│Ж р▓Зр▓▓р│Нр▓▓р▓╡р│З?",
    signUp: "р▓╕р│Ир▓ир│Н р▓Ер▓кр│Н р▓ор▓╛р▓бр▓┐",
    alreadyHaveAccount: "р▓Ир▓Чр▓╛р▓Чр▓▓р│З р▓Цр▓╛р▓др│Ж р▓Зр▓жр│Жр▓пр│З?",
    backToEmailLogin: "р▓Зр▓ор│Зр▓▓р│Н р▓▓р▓╛р▓Чр▓┐р▓ир│НтАМр▓Чр│Ж р▓╣р▓┐р▓Вр▓др▓┐р▓░р│Бр▓Чр▓┐",
    enterPhoneNumber: "р▓лр│Лр▓ир│Н р▓╕р▓Вр▓Цр│Нр▓пр│Ж р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐ (р▓Йр▓жр▓╛: +919876543210)",
    sendOtp: "OTP р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓┐",
    enterVerificationCode: "р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓ир▓╛ р▓Хр│Лр▓бр│Н р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐", // Used for placeholder
    verifyOtp: "OTP р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓┐р▓╕р▓┐",
    otpSent: "р▓ир▓┐р▓ор│Нр▓о р▓лр│Лр▓ир│НтАМр▓Чр│Ж OTP р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓▓р▓╛р▓Чр▓┐р▓жр│Ж!",
    whatsInKitchen: "р▓ир▓┐р▓ор│Нр▓о р▓Ер▓бр│Бр▓Чр│Жр▓ор▓ир│Жр▓пр▓▓р│Нр▓▓р▓┐ р▓Пр▓ир▓┐р▓жр│Ж?",
    enterIngredient: "р▓кр▓жр▓╛р▓░р│Нр▓е р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐ (р▓Йр▓жр▓╛: 'р▓Ър▓┐р▓Хр▓ир│Н', 'р▓Ер▓Хр│Нр▓Хр▓┐')",
    addIngredient: "р▓кр▓жр▓╛р▓░р│Нр▓е р▓╕р│Зр▓░р▓┐р▓╕р▓┐",
    yourIngredients: "р▓ир▓┐р▓ор│Нр▓о р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р│Б:",
    clearAll: "р▓Ор▓▓р│Нр▓▓р▓╡р▓ир│Нр▓ир│В р▓др│Жр▓░р▓╡р│Бр▓Чр│Кр▓│р▓┐р▓╕р▓┐",
    selectCuisine: "р▓Ер▓бр│Бр▓Чр│Ж р▓╢р│Ир▓▓р▓┐ р▓Жр▓пр│Нр▓Хр│Жр▓ор▓╛р▓бр▓┐ (р▓Рр▓Ър│Нр▓Ыр▓┐р▓Х):",
    anyCuisine: "р▓пр▓╛р▓╡р│Бр▓жр│З р▓Ер▓бр│Бр▓Чр│Ж р▓╢р│Ир▓▓р▓┐",
    findRecipes: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р▓ир│Нр▓ир│Б р▓╣р│Бр▓бр│Бр▓Хр▓┐",
    recommendedRecipes: "р▓╢р▓┐р▓лр▓╛р▓░р▓╕р│Б р▓ор▓╛р▓бр▓┐р▓ж р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р│Б",
    backToIngredients: "р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р▓┐р▓Чр│Ж р▓╣р▓┐р▓Вр▓др▓┐р▓░р│Бр▓Чр▓┐",
    ingredients: "р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р│Б",
    description: "р▓╡р▓┐р▓╡р▓░р▓гр│Ж",
    startCookingProcedure: "р▓Ер▓бр│Бр▓Чр│Ж р▓╡р▓┐р▓зр▓╛р▓и р▓кр│Нр▓░р▓╛р▓░р▓Вр▓нр▓┐р▓╕р▓┐",
    copyRecipe: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓и р▓ир▓Хр▓▓р▓┐р▓╕р▓┐",
    copied: "р▓ир▓Хр▓▓р▓┐р▓╕р▓▓р▓╛р▓Чр▓┐р▓жр│Ж!",
    cookingProcedure: "р▓Ер▓бр│Бр▓Чр│Ж р▓╡р▓┐р▓зр▓╛р▓и",
    step: "р▓╣р▓Вр▓д",
    previousStep: "р▓╣р▓┐р▓Вр▓жр▓┐р▓и р▓╣р▓Вр▓д",
    nextStep: "р▓ор│Бр▓Вр▓жр▓┐р▓и р▓╣р▓Вр▓д",
    finishCooking: "р▓Ер▓бр│Бр▓Чр│Ж р▓ор│Бр▓Чр▓┐р▓╕р▓┐!",
    congratulations: "ЁЯОЙ р▓Ер▓нр▓┐р▓ир▓Вр▓жр▓ир│Жр▓Чр▓│р│Б! ЁЯОЙ",
    recipeCompleted: "р▓ир│Ар▓╡р│Б р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓╡р▓ир│Нр▓ир│Б р▓пр▓╢р▓╕р│Нр▓╡р▓┐р▓пр▓╛р▓Чр▓┐ р▓кр│Вр▓░р│Нр▓гр▓Чр│Кр▓│р▓┐р▓╕р▓┐р▓жр│Нр▓жр│Ар▓░р▓┐:",
    cookAnotherRecipe: "р▓ор▓др│Нр▓др│Кр▓Вр▓жр│Б р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓и р▓ор▓╛р▓бр▓┐",
    logout: "р▓▓р▓╛р▓Чр│Н р▓Фр▓Яр│Н",
    loadingApp: "р▓Ер▓кр│Нр▓▓р▓┐р▓Хр│Зр▓╢р▓ир│Н р▓▓р│Лр▓бр│Н р▓Жр▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...",
    error: "р▓жр│Лр▓╖:",
    pleaseAddIngredient: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р▓ир│Нр▓ир│Б р▓╣р│Бр▓бр│Бр▓Хр▓▓р│Б р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓Хр▓ир▓┐р▓╖р│Нр▓а р▓Тр▓Вр▓жр│Б р▓кр▓жр▓╛р▓░р│Нр▓ер▓╡р▓ир│Нр▓ир│Б р▓╕р│Зр▓░р▓┐р▓╕р▓┐.",
    failedToFetchRecipes: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р▓ир│Нр▓ир│Б р▓кр▓бр│Жр▓пр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж:",
    noRecipesFound: "р▓ир▓┐р▓ор│Нр▓о р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р│Б р▓ор▓др│Нр▓др│Б р▓Ер▓бр│Бр▓Чр│Ж р▓╢р│Ир▓▓р▓┐р▓Чр│Ж р▓пр▓╛р▓╡р│Бр▓жр│З р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р│Б р▓Хр▓Вр▓бр│Бр▓мр▓Вр▓жр▓┐р▓▓р│Нр▓▓. р▓╣р│Жр▓Ър│Нр▓Ър▓┐р▓ир▓жр▓ир│Нр▓ир│Б р▓╕р│Зр▓░р▓┐р▓╕р▓┐ р▓Ер▓ер▓╡р▓╛ р▓Ер▓бр│Бр▓Чр│Ж р▓╢р│Ир▓▓р▓┐р▓пр▓ир│Нр▓ир│Б р▓мр▓жр▓▓р▓╛р▓пр▓┐р▓╕р▓┐!",
    settings: "р▓╕р│Жр▓Яр│Нр▓Яр▓┐р▓Вр▓Чр│НтАМр▓Чр▓│р│Б",
    language: "р▓нр▓╛р▓╖р│Ж",
    popularDishes: "р▓Ьр▓ир▓кр│Нр▓░р▓┐р▓п р▓Цр▓╛р▓жр│Нр▓пр▓Чр▓│р│Б",
    viewPopularDishes: "р▓Ьр▓ир▓кр│Нр▓░р▓┐р▓п р▓Цр▓╛р▓жр│Нр▓пр▓Чр▓│р▓ир│Нр▓ир│Б р▓╡р│Ар▓Хр│Нр▓╖р▓┐р▓╕р▓┐",
    backToHome: "р▓ор│Бр▓Цр▓кр│Бр▓Яр▓Хр│Нр▓Хр│Ж р▓╣р▓┐р▓Вр▓др▓┐р▓░р│Бр▓Чр▓┐",
    noInstructions: "р▓И р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Хр│Нр▓Хр│Ж р▓пр▓╛р▓╡р│Бр▓жр│З р▓╡р▓┐р▓╡р▓░р▓╡р▓╛р▓ж р▓╕р│Вр▓Ър▓ир│Жр▓Чр▓│р│Б р▓▓р▓нр│Нр▓пр▓╡р▓┐р▓▓р│Нр▓▓.",
    failedToLoadUserData: "р▓мр▓│р▓Хр│Жр▓жр▓╛р▓░ р▓бр│Зр▓Яр▓╛р▓╡р▓ир│Нр▓ир│Б р▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    failedToSaveIngredient: "р▓Хр│Нр▓▓р│Мр▓бр│НтАМр▓Чр│Ж р▓кр▓жр▓╛р▓░р│Нр▓ер▓╡р▓ир│Нр▓ир│Б р▓Йр▓│р▓┐р▓╕р▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    failedToRemoveIngredient: "р▓Хр│Нр▓▓р│Мр▓бр│НтАМр▓ир▓┐р▓Вр▓ж р▓кр▓жр▓╛р▓░р│Нр▓ер▓╡р▓ир│Нр▓ир│Б р▓др│Жр▓Чр│Жр▓жр│Бр▓╣р▓╛р▓Хр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    failedToClearIngredients: "р▓Хр│Нр▓▓р│Мр▓бр│НтАМр▓ир▓▓р│Нр▓▓р▓┐р▓░р│Бр▓╡ р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р▓ир│Нр▓ир│Б р▓др│Жр▓░р▓╡р│Бр▓Чр│Кр▓│р▓┐р▓╕р▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    securityCheckNotReady: "р▓нр▓жр│Нр▓░р▓др▓╛ р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓ир│Ж р▓╕р▓┐р▓жр│Нр▓зр▓╡р▓╛р▓Чр▓┐р▓▓р│Нр▓▓. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор▓др│Нр▓др│Ж р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    firebaseAuthNotInitialized: "р▓лр│Ир▓░р│НтАМр▓мр│Зр▓╕р│Н р▓жр│Гр▓вр│Ар▓Хр▓░р▓г р▓кр│Нр▓░р▓╛р▓░р▓Вр▓нр▓╡р▓╛р▓Чр▓┐р▓▓р│Нр▓▓.",
    pleaseSendOtpFirst: "р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ор│Кр▓жр▓▓р│Б OTP р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓┐.",
    enterVerificationCodeError: "р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓ир▓╛ р▓Хр│Лр▓бр│Н р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐уАВ", // Used for error message
    otpExpired: "р▓░р│Ар▓Хр│Нр▓пр▓╛р▓кр│Нр▓Ър▓╛ р▓Ер▓╡р▓зр▓┐ р▓ор│Бр▓Чр▓┐р▓жр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б OTP р▓Ер▓ир│Нр▓ир│Б р▓ор▓др│Нр▓др│Ж р▓Хр▓│р│Бр▓╣р▓┐р▓╕р▓▓р│Б р▓кр│Нр▓░р▓пр▓др│Нр▓ир▓┐р▓╕р▓┐.",
    failedToLoadSecurity: "р▓нр▓жр│Нр▓░р▓др▓╛ р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓ир│Жр▓пр▓ир│Нр▓ир│Б р▓▓р│Лр▓бр│Н р▓ор▓╛р▓бр▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓░р▓┐р▓лр│Нр▓░р│Жр▓╢р│Н р▓ор▓╛р▓бр▓┐.",
    failedToInitAuth: "р▓жр│Гр▓вр│Ар▓Хр▓░р▓гр▓╡р▓ир│Нр▓ир│Б р▓кр│Нр▓░р▓╛р▓░р▓Вр▓нр▓┐р▓╕р▓▓р│Б р▓╡р▓┐р▓лр▓▓р▓╡р▓╛р▓Чр▓┐р▓жр│Ж. р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓ир▓┐р▓ор│Нр▓о р▓лр│Ир▓░р│НтАМр▓мр│Зр▓╕р│Н р▓Хр▓╛р▓ир│Нр▓лр▓┐р▓Чр▓░р│Зр▓╢р▓ир│Н р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓┐р▓╕р▓┐уАВ",
    translatingContent: "р▓╡р▓┐р▓╖р▓пр▓╡р▓ир│Нр▓ир│Б р▓Ер▓ир│Бр▓╡р▓╛р▓жр▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж",
    yourDish: "р▓ир▓┐р▓ор│Нр▓о р▓Цр▓╛р▓жр│Нр▓п",
    addSomeIngredients: "р▓кр│Нр▓░р▓╛р▓░р▓Вр▓нр▓┐р▓╕р▓▓р│Б р▓Хр│Жр▓▓р▓╡р│Б р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р▓ир│Нр▓ир│Б р▓╕р│Зр▓░р▓┐р▓╕р▓┐!",
    noDescription: "р▓И р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Хр│Нр▓Хр│Ж р▓пр▓╛р▓╡р│Бр▓жр│З р▓╡р▓┐р▓╡р▓░р▓гр│Ж р▓▓р▓нр│Нр▓пр▓╡р▓┐р▓▓р│Нр▓▓.",
    recipe: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓и",
    backToRecipes: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓Чр▓│р▓┐р▓Чр│Ж р▓╣р▓┐р▓Вр▓др▓┐р▓░р│Бр▓Чр▓┐",
    defaultCuisine: "р▓бр│Ар▓лр▓╛р▓▓р│Нр▓Яр│Н р▓Ер▓бр│Бр▓Чр│Ж р▓╢р│Ир▓▓р▓┐", // New translation key
    backToDetails: "р▓╡р▓┐р▓╡р▓░р▓Чр▓│р▓┐р▓Чр│Ж р▓╣р▓┐р▓Вр▓др▓┐р▓░р│Бр▓Чр▓┐", // New translation for procedure screen
    substitute: "р▓мр▓жр▓▓р▓╛р▓╡р▓гр│Ж", // New translation key
    ingredientSubstitutions: "р▓кр▓жр▓╛р▓░р│Нр▓ер▓ж р▓кр▓░р│Нр▓пр▓╛р▓пр▓Чр▓│р│Б", // New translation key
    creativeRecipeIdea: "р▓╕р│Гр▓Ьр▓ир▓╛р▓др│Нр▓ор▓Х р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓и р▓Хр▓▓р│Нр▓кр▓ир│Ж", // New translation key
    generateCreativeIdea: "р▓╕р│Гр▓Ьр▓ир▓╛р▓др│Нр▓ор▓Х р▓Хр▓▓р│Нр▓кр▓ир│Жр▓пр▓ир│Нр▓ир│Б р▓░р▓Ър▓┐р▓╕р▓┐", // New translation key
    recipeName: "р▓кр▓╛р▓Хр▓╡р▓┐р▓зр▓╛р▓ир▓ж р▓╣р│Жр▓╕р▓░р│Б", // New translation key
    keyIngredients: "р▓кр│Нр▓░р▓ор│Бр▓Ц р▓кр▓жр▓╛р▓░р│Нр▓ер▓Чр▓│р│Б", // New translation key
    close: "р▓ор│Бр▓Ър│Нр▓Ър▓┐", // New translation key
    generatingIdea: "р▓Хр▓▓р│Нр▓кр▓ир│Ж р▓░р▓Ър▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...", // New translation key
    findingSubstitutions: "р▓кр▓░р│Нр▓пр▓╛р▓пр▓Чр▓│р▓ир│Нр▓ир│Б р▓╣р│Бр▓бр│Бр▓Хр▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...", // New translation key
    shortProcedure: "р▓╕р▓Вр▓Хр│Нр▓╖р▓┐р▓кр│Нр▓д р▓╡р▓┐р▓зр▓╛р▓и", // New translation key
    noIdeaGenerated: "р▓пр▓╛р▓╡р│Бр▓жр│З р▓Хр▓▓р│Нр▓кр▓ир│Ж р▓░р▓Ър▓┐р▓╕р▓▓р▓╛р▓Чр▓┐р▓▓р│Нр▓▓.", // New translation key
    noSuggestionsFound: "р▓пр▓╛р▓╡р│Бр▓жр│З р▓╕р▓▓р▓╣р│Жр▓Чр▓│р│Б р▓Хр▓Вр▓бр│Бр▓мр▓Вр▓жр▓┐р▓▓р│Нр▓▓.", // New translation key
  },
  ta: { // Tamil
    welcomeBack: "роорпАрогрпНроЯрпБроорпН ро╡ро░рпБроХ!",
    createAccount: "роХрогроХрпНроХрпИ роЙро░рпБро╡ро╛роХрпНроХрпБ",
    loginWithPhone: "родрпКро▓рпИрокрпЗроЪро┐ роорпВро▓роорпН роЙро│рпНроирпБро┤рпИроХ",
    loginWithGoogle: "роХрпВроХро┐ро│рпН роорпВро▓роорпН роЙро│рпНроирпБро┤рпИроХ", // New translation key
    email: "рооро┐ройрпНройроЮрпНроЪро▓рпН",
    password: "роХроЯро╡рпБроЪрпНроЪрпКро▓рпН",
    loginWithEmail: "рооро┐ройрпНройроЮрпНроЪро▓рпН роорпВро▓роорпН роЙро│рпНроирпБро┤рпИ",
    dontHaveAccount: "роХрогроХрпНроХрпБ роЗро▓рпНро▓рпИропро╛?",
    signUp: "рокродро┐ро╡рпБ роЪрпЖропрпНроХ",
    alreadyHaveAccount: "роПро▒рпНроХройро╡рпЗ роХрогроХрпНроХрпБ роЙро│рпНро│родро╛?",
    backToEmailLogin: "рооро┐ройрпНройроЮрпНроЪро▓рпН роЙро│рпНроирпБро┤рпИро╡рпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ",
    enterPhoneNumber: "родрпКро▓рпИрокрпЗроЪро┐ роОрогрпНрогрпИ роЙро│рпНро│ро┐роЯро╡рпБроорпН (роО.роХро╛: +919876543210)",
    sendOtp: "OTP роЕройрпБрокрпНрокрпБ",
    enterVerificationCode: "роЪро░ро┐рокро╛ро░рпНрокрпНрокрпБ роХрпБро▒ро┐ропрпАроЯрпНроЯрпИ роЙро│рпНро│ро┐роЯро╡рпБроорпН", // Used for placeholder
    verifyOtp: "OTP роЪро░ро┐рокро╛ро░рпНроХрпНроХро╡рпБроорпН",
    otpSent: "роЙроЩрпНроХро│рпН родрпКро▓рпИрокрпЗроЪро┐роХрпНроХрпБ OTP роЕройрпБрокрпНрокрокрпНрокроЯрпНроЯродрпБ!",
    whatsInKitchen: "роЙроЩрпНроХро│рпН роЪроорпИропро▓ро▒рпИропро┐ро▓рпН роОройрпНрой роЗро░рпБроХрпНроХро┐ро▒родрпБ?",
    enterIngredient: "рокрпКро░рпБро│рпИ роЙро│рпНро│ро┐роЯро╡рпБроорпН (роО.роХро╛: 'роЪро┐роХрпНроХройрпН', 'роЕро░ро┐роЪро┐')",
    addIngredient: "рокрпКро░рпБро│рпИроЪрпН роЪрпЗро░рпН",
    yourIngredients: "роЙроЩрпНроХро│рпН рокрпКро░рпБроЯрпНроХро│рпН:",
    clearAll: "роЕройрпИродрпНродрпИропрпБроорпН роЕро┤ро┐",
    selectCuisine: "роЪроорпИропро▓рпН ро╡роХрпИропрпИродрпН родрпЗро░рпНроирпНродрпЖроЯрпБроХрпНроХро╡рпБроорпН (ро╡ро┐ро░рпБроорпНрокро┐ройро╛ро▓рпН):",
    anyCuisine: "роОроирпНрод роЪроорпИропро▓рпН ро╡роХрпИ",
    findRecipes: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпИроХрпН роХрогрпНроЯро▒ро┐ропро╡рпБроорпН",
    recommendedRecipes: "рокро░ро┐роирпНродрпБро░рпИроХрпНроХрокрпНрокроЯрпНроЯ роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпН",
    backToIngredients: "рокрпКро░рпБроЯрпНроХро│рпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ",
    ingredients: "рокрпКро░рпБроЯрпНроХро│рпН",
    description: "ро╡ро┐ро│роХрпНроХроорпН",
    startCookingProcedure: "роЪроорпИропро▓рпН роЪрпЖропрпНроорпБро▒рпИропрпИродрпН родрпКроЯроЩрпНроХрпБ",
    copyRecipe: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпИ роироХро▓рпЖроЯрпБ",
    copied: "роироХро▓рпЖроЯрпБроХрпНроХрокрпНрокроЯрпНроЯродрпБ!",
    cookingProcedure: "роЪроорпИропро▓рпН роЪрпЖропрпНроорпБро▒рпИ",
    step: "рокроЯро┐",
    previousStep: "роорпБроирпНродрпИроп рокроЯро┐",
    nextStep: "роЕроЯрпБродрпНрод рокроЯро┐",
    finishCooking: "роЪроорпИропро▓рпИ роорпБроЯро┐!",
    congratulations: "ЁЯОЙ ро╡ро╛ро┤рпНродрпНродрпБроХрпНроХро│рпН! ЁЯОЙ",
    recipeCompleted: "роирпАроЩрпНроХро│рпН роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпИ ро╡рпЖро▒рпНро▒ро┐роХро░рооро╛роХ роорпБроЯро┐родрпНродрпБро╡ро┐роЯрпНроЯрпАро░рпНроХро│рпН:",
    cookAnotherRecipe: "рооро▒рпНро▒рпКро░рпБ роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпИ роЪроорпИ",
    logout: "ро╡рпЖро│ро┐ропрпЗро▒рпБ",
    loadingApp: "рокропройрпНрокро╛роЯрпБ роПро▒рпНро▒рокрпНрокроЯрпБроХро┐ро▒родрпБ...",
    error: "рокро┐ро┤рпИ:",
    pleaseAddIngredient: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпИроХрпН роХрогрпНроЯро▒ро┐роп роХрпБро▒рпИроирпНродрокроЯрпНроЪроорпН роТро░рпБ рокрпКро░рпБро│рпИроЪрпН роЪрпЗро░рпНроХрпНроХро╡рпБроорпН.",
    failedToFetchRecipes: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпИрокрпН рокрпЖро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ:",
    noRecipesFound: "роЙроЩрпНроХро│рпН рокрпКро░рпБроЯрпНроХро│рпН рооро▒рпНро▒рпБроорпН роЪроорпИропро▓рпН ро╡роХрпИроХрпНроХрпБ роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпН роОродрпБро╡рпБроорпН роЗро▓рпНро▓рпИ. роорпЗро▓рпБроорпН роЪрпЗро░рпНроХрпНроХро╡рпБроорпН роЕро▓рпНро▓родрпБ роЪроорпИропро▓рпН ро╡роХрпИропрпИ рооро╛ро▒рпНро▒ро╡рпБроорпН!",
    settings: "роЕроорпИрокрпНрокрпБроХро│рпН",
    language: "роорпКро┤ро┐",
    popularDishes: "рокро┐ро░рокро▓рооро╛рой роЙрогро╡рпБроХро│рпН",
    viewPopularDishes: "рокро┐ро░рокро▓рооро╛рой роЙрогро╡рпБроХро│рпИроХрпН роХро╛рогрпНроХ",
    backToHome: "роорпБроХрокрпНрокрпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ",
    noInstructions: "роЗроирпНрод роЪрпЖропрпНроорпБро▒рпИроХрпНроХрпБ ро╡ро┐ро░ро┐ро╡ро╛рой ро╡ро┤ро┐роорпБро▒рпИроХро│рпН роОродрпБро╡рпБроорпН роЗро▓рпНро▓рпИ.",
    failedToLoadUserData: "рокропройро░рпН родро░ро╡рпИ роПро▒рпНро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    failedToSaveIngredient: "роХро┐ро│ро╡рпБроЯрпНроЯро┐ро▓рпН рокрпКро░рпБро│рпИ роЪрпЗрооро┐роХрпНроХ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    failedToRemoveIngredient: "роХро┐ро│ро╡рпБроЯрпНроЯро┐ро▓рпН роЗро░рпБроирпНродрпБ рокрпКро░рпБро│рпИ роЕроХро▒рпНро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    failedToClearIngredients: "роХро┐ро│ро╡рпБроЯрпНроЯро┐ро▓рпН роЙро│рпНро│ рокрпКро░рпБроЯрпНроХро│рпИ роЕро┤ро┐роХрпНроХ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    securityCheckNotReady: "рокро╛родрпБроХро╛рокрпНрокрпБроЪрпН роЪро░ро┐рокро╛ро░рпНрокрпНрокрпБ родропро╛ро░ро╛роХ роЗро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    firebaseAuthNotInitialized: "роГрокропро░рпНрокрпЗро╕рпН роЕроЩрпНроХрпАроХро╛ро░роорпН родрпКроЯроЩрпНроХрокрпНрокроЯро╡ро┐ро▓рпНро▓рпИ.",
    pleaseSendOtpFirst: "родропро╡рпБроЪрпЖропрпНродрпБ роорпБродро▓ро┐ро▓рпН OTP роР роЕройрпБрокрпНрокро╡рпБроорпН.",
    enterVerificationCodeError: "родропро╡рпБроЪрпЖропрпНродрпБ роЪро░ро┐рокро╛ро░рпНрокрпНрокрпБ роХрпБро▒ро┐ропрпАроЯрпНроЯрпИ роЙро│рпНро│ро┐роЯро╡рпБроорпНуАВ", // Used for error message
    otpExpired: "ро░рпАроХрпЗрокрпНроЪро╛ роХро╛ро▓ро╛ро╡родро┐ропро╛ройродрпБ. родропро╡рпБроЪрпЖропрпНродрпБ OTP роР роорпАрогрпНроЯрпБроорпН роЕройрпБрокрпНрок роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.",
    failedToLoadSecurity: "рокро╛родрпБроХро╛рокрпНрокрпБроЪрпН роЪро░ро┐рокро╛ро░рпНрокрпНрокрпИ роПро▒рпНро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. рокрпБродрпБрокрпНрокро┐роХрпНроХро╡рпБроорпН.",
    failedToInitAuth: "роЕроЩрпНроХрпАроХро╛ро░родрпНродрпИродрпН родрпКроЯроЩрпНроХ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роЙроЩрпНроХро│рпН роГрокропро░рпНрокрпЗро╕рпН роЙро│рпНро│роорпИро╡рпИроЪрпН роЪро░ро┐рокро╛ро░рпНроХрпНроХро╡рпБроорпНуАВ",
    translatingContent: "роЙро│рпНро│роЯроХрпНроХроорпН роорпКро┤ро┐рокрпЖропро░рпНроХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБ",
    yourDish: "роЙроЩрпНроХро│рпН роЯро┐ро╖рпН",
    addSomeIngredients: "родрпКроЯроЩрпНроХрпБро╡родро▒рпНроХрпБ роЪро┐ро▓ рокрпКро░рпБроЯрпНроХро│рпИроЪрпН роЪрпЗро░рпНроХрпНроХро╡рпБроорпН!",
    noDescription: "роЗроирпНрод роЪрпЖропрпНроорпБро▒рпИроХрпНроХрпБ ро╡ро┐ро│роХрпНроХроорпН роОродрпБро╡рпБроорпН роЗро▓рпНро▓рпИуАВ",
    recipe: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБ",
    backToRecipes: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБроХро│рпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ",
    defaultCuisine: "роЗропро▓рпНрокрпБроиро┐ро▓рпИ роЪроорпИропро▓рпН ро╡роХрпИ", // New translation key
    backToDetails: "ро╡ро┐ро╡ро░роЩрпНроХро│рпБроХрпНроХрпБродрпН родро┐ро░рпБроорпНрокрпБ", // New translation for procedure screen
    substitute: "рокродро┐ро▓рпАроЯрпБ", // New translation key
    ingredientSubstitutions: "рокрпКро░рпБроЯрпНроХро│ро┐ройрпН рокродро┐ро▓рпАроЯрпБроХро│рпН", // New translation key
    creativeRecipeIdea: "рокроЯрпИрокрпНрокрпБ роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБ ропрпЛроЪройрпИ", // New translation key
    generateCreativeIdea: "рокроЯрпИрокрпНрокрпБ ропрпЛроЪройрпИропрпИ роЙро░рпБро╡ро╛роХрпНроХрпБ", // New translation key
    recipeName: "роЪроорпИропро▓рпН роХрпБро▒ро┐рокрпНрокрпБ рокрпЖропро░рпН", // New translation key
    keyIngredients: "роорпБроХрпНроХро┐роп рокрпКро░рпБроЯрпНроХро│рпН", // New translation key
    close: "роорпВроЯрпБ", // New translation key
    generatingIdea: "ропрпЛроЪройрпИ роЙро░рпБро╡ро╛роХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБ...", // New translation key
    findingSubstitutions: "рокродро┐ро▓рпАроЯрпБроХро│рпИроХрпН роХрогрпНроЯро▒ро┐родро▓рпН...", // New translation key
    shortProcedure: "роХрпБро▒рпБроХро┐роп роЪрпЖропро▓рпНроорпБро▒рпИ", // New translation key
    noIdeaGenerated: "роОроирпНрод ропрпЛроЪройрпИропрпБроорпН роЙро░рпБро╡ро╛роХрпНроХрокрпНрокроЯро╡ро┐ро▓рпНро▓рпИ.", // New translation key
    noSuggestionsFound: "роОроирпНрод рокро░ро┐роирпНродрпБро░рпИроХро│рпБроорпН роЗро▓рпНро▓рпИ.", // New translation key
  },
  ml: { // Malayalam
    welcomeBack: "р┤╕р╡Нр┤╡р┤╛р┤Чр┤др┤В!",
    createAccount: "р┤Ер┤Хр╡Нр┤Хр╡Чр┤гр╡Нр┤Яр╡Н р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤Х",
    loginWithPhone: "р┤лр╡Лр╡║ р┤ир┤ор╡Нр┤кр╡╝ р┤Йр┤кр┤пр╡Лр┤Чр┤┐р┤Ър╡Нр┤Ър╡Н р┤▓р╡Лр┤Чр┤┐р╡╗ р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х",
    loginWithGoogle: "р┤Чр╡Вр┤Чр┤┐р╡╛ р┤Йр┤кр┤пр╡Лр┤Чр┤┐р┤Ър╡Нр┤Ър╡Н р┤▓р╡Лр┤Чр┤┐р╡╗ р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х", // New translation key
    email: "р┤Зр┤ор╡Жр┤пр┤┐р╡╜",
    password: "р┤кр┤╛р┤╕р╡НтАМр┤╡р╡Зр┤бр╡Н",
    loginWithEmail: "р┤Зр┤ор╡Жр┤пр┤┐р╡╜ р┤Йр┤кр┤пр╡Лр┤Чр┤┐р┤Ър╡Нр┤Ър╡Н р┤▓р╡Лр┤Чр┤┐р╡╗ р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х",
    dontHaveAccount: "р┤Ер┤Хр╡Нр┤Хр╡Чр┤гр╡Нр┤Яр╡Н р┤Зр┤▓р╡Нр┤▓р╡З?",
    signUp: "р┤╕р╡Ир╡╗ р┤Ер┤кр╡Нр┤кр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х",
    alreadyHaveAccount: "р┤ор╡Бр┤ор╡Нр┤кр╡З р┤Ер┤Хр╡Нр┤Хр╡Чр┤гр╡Нр┤Яр╡Н р┤Йр┤гр╡Нр┤Яр╡Л?",
    backToEmailLogin: "р┤Зр┤ор╡Жр┤пр┤┐р╡╜ р┤▓р╡Лр┤Чр┤┐р┤ир┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤др┤┐р┤░р┤┐р┤Хр╡Ж",
    enterPhoneNumber: "р┤лр╡Лр╡║ р┤ир┤ор╡Нр┤кр╡╝ р┤ир╡╜р┤Хр╡Бр┤Х (р┤Йр┤жр┤╛: +919876543210)",
    sendOtp: "OTP р┤Ер┤пр┤Хр╡Нр┤Хр╡Бр┤Х",
    enterVerificationCode: "р┤╕р╡Нр┤ер┤┐р┤░р╡Ар┤Хр┤░р┤г р┤Хр╡Лр┤бр╡Н р┤ир╡╜р┤Хр╡Бр┤Х", // Used for placeholder
    verifyOtp: "OTP р┤╕р╡Нр┤ер┤┐р┤░р╡Ар┤Хр┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х",
    otpSent: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤лр╡Лр┤гр┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н OTP р┤Ер┤пр┤Ър╡Нр┤Ър┤┐р┤Яр╡Нр┤Яр╡Бр┤гр╡Нр┤Яр╡Н!",
    whatsInKitchen: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤Ер┤Яр╡Бр┤Хр╡Нр┤Хр┤│р┤пр┤┐р╡╜ р┤Ор┤ир╡Нр┤др╡Кр┤Хр╡Нр┤Хр╡Жр┤пр╡Бр┤гр╡Нр┤Яр╡Н?",
    enterIngredient: "р┤Ър╡Зр┤░р╡Бр┤╡ р┤ир╡╜р┤Хр╡Бр┤Х (р┤Йр┤жр┤╛: 'р┤Ър┤┐р┤Хр╡Нр┤Хр╡╗', 'р┤Ер┤░р┤┐')",
    addIngredient: "р┤Ър╡Зр┤░р╡Бр┤╡ р┤Ър╡Зр╡╝р┤Хр╡Нр┤Хр╡Бр┤Х",
    yourIngredients: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛:",
    clearAll: "р┤Ор┤▓р╡Нр┤▓р┤╛р┤В р┤ор┤╛р┤пр╡Нр┤Хр╡Нр┤Хр╡Бр┤Х",
    selectCuisine: "р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐ р┤др┤┐р┤░р┤Юр╡Нр┤Юр╡Жр┤Яр╡Бр┤Хр╡Нр┤Хр╡Бр┤Х (р┤Ур┤кр╡Нр┤╖р┤гр╡╜):",
    anyCuisine: "р┤Пр┤др╡Н р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐р┤пр╡Бр┤В",
    findRecipes: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр╡╛ р┤Хр┤гр╡Нр┤Яр╡Жр┤др╡Нр┤др╡Бр┤Х",
    recommendedRecipes: "р┤╢р╡Бр┤кр┤╛р╡╝р┤╢ р┤Ър╡Жр┤пр╡Нр┤д р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр╡╛",
    backToIngredients: "р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр┤│р┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤др┤┐р┤░р┤┐р┤Хр╡Ж",
    ingredients: "р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛",
    description: "р┤╡р┤┐р┤╡р┤░р┤гр┤В",
    startCookingProcedure: "р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐ р┤Жр┤░р┤Вр┤нр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х",
    copyRecipe: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н р┤кр┤Хр╡╝р┤др╡Нр┤др╡Бр┤Х",
    copied: "р┤кр┤Хр╡╝р┤др╡Нр┤др┤┐!",
    cookingProcedure: "р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐",
    step: "р┤Шр┤Яр╡Нр┤Яр┤В",
    previousStep: "р┤ор╡Бр┤ор╡Нр┤кр┤др╡Нр┤др╡Ж р┤Шр┤Яр╡Нр┤Яр┤В",
    nextStep: "р┤Ер┤Яр╡Бр┤др╡Нр┤д р┤Шр┤Яр╡Нр┤Яр┤В",
    finishCooking: "р┤кр┤╛р┤Ър┤Хр┤В р┤кр╡Вр╡╝р┤др╡Нр┤др┤┐р┤пр┤╛р┤Хр╡Нр┤Хр╡Бр┤Х!",
    congratulations: "ЁЯОЙ р┤Ер┤нр┤┐р┤ир┤ир╡Нр┤жр┤ир┤Щр╡Нр┤Щр╡╛! ЁЯОЙ",
    recipeCompleted: "р┤ир┤┐р┤Щр╡Нр┤Щр╡╛ р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н р┤╡р┤┐р┤Ьр┤пр┤Хр┤░р┤ор┤╛р┤пр┤┐ р┤кр╡Вр╡╝р┤др╡Нр┤др┤┐р┤пр┤╛р┤Хр╡Нр┤Хр┤┐р┤пр┤┐р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б:",
    cookAnotherRecipe: "р┤ор┤▒р╡Нр┤▒р╡Кр┤░р╡Б р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤Х",
    logout: "р┤кр╡Бр┤▒р┤др╡Нр┤др╡Бр┤Хр┤Яр┤Хр╡Нр┤Хр╡Бр┤Х",
    loadingApp: "р┤Жр┤кр╡Нр┤кр╡Н р┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир╡Б...",
    error: "р┤кр┤┐р┤╢р┤Хр╡Н:",
    pleaseAddIngredient: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр╡╛ р┤Хр┤гр╡Нр┤Яр╡Жр┤др╡Нр┤др┤╛р╡╗ р┤Хр╡Бр┤▒р┤Юр╡Нр┤Юр┤др╡Н р┤Тр┤░р╡Б р┤Ър╡Зр┤░р╡Бр┤╡р┤пр╡Жр┤Щр╡Нр┤Хр┤┐р┤▓р╡Бр┤В р┤Ър╡Зр╡╝р┤Хр╡Нр┤Хр╡Бр┤Х.",
    failedToFetchRecipes: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр╡╛ р┤▓р┤нр┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б:",
    noRecipesFound: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛р┤Хр╡Нр┤Хр╡Бр┤В р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐р┤Хр╡Нр┤Хр╡Бр┤В р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр┤│р╡Кр┤ир╡Нр┤ир╡Бр┤В р┤Хр┤гр╡Нр┤Яр╡Жр┤др╡Нр┤др┤┐р┤пр┤┐р┤▓р╡Нр┤▓. р┤Хр╡Вр┤Яр╡Бр┤др╡╜ р┤Ър╡Зр╡╝р┤Хр╡Нр┤Хр╡Бр┤Х р┤Ер┤▓р╡Нр┤▓р╡Жр┤Щр╡Нр┤Хр┤┐р╡╜ р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐ р┤ор┤╛р┤▒р╡Нр┤▒р╡Бр┤Х!",
    settings: "р┤Хр╡Нр┤░р┤ор╡Ар┤Хр┤░р┤гр┤Щр╡Нр┤Щр╡╛",
    language: "р┤нр┤╛р┤╖",
    popularDishes: "р┤кр╡Нр┤░р┤╢р┤╕р╡Нр┤д р┤╡р┤┐р┤нр┤╡р┤Щр╡Нр┤Щр╡╛",
    viewPopularDishes: "р┤кр╡Нр┤░р┤╢р┤╕р╡Нр┤д р┤╡р┤┐р┤нр┤╡р┤Щр╡Нр┤Щр╡╛ р┤Хр┤╛р┤гр╡Бр┤Х",
    backToHome: "р┤╣р╡Лр┤ор┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤др┤┐р┤░р┤┐р┤Хр╡Ж",
    noInstructions: "р┤И р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр┤┐р┤ир╡Н р┤╡р┤┐р┤╢р┤жр┤ор┤╛р┤п р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤Щр╡Нр┤Щр┤│р╡Кр┤ир╡Нр┤ир╡Бр┤В р┤▓р┤нр╡Нр┤пр┤ор┤▓р╡Нр┤▓.",
    failedToLoadUserData: "р┤Йр┤кр┤пр╡Лр┤Хр╡Нр┤др╡Г р┤бр┤╛р┤▒р╡Нр┤▒ р┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    failedToSaveIngredient: "р┤Хр╡Нр┤▓р╡Чр┤бр┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤Ър╡Зр┤░р╡Бр┤╡ р┤╕р┤Вр┤░р┤Хр╡Нр┤╖р┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    failedToRemoveIngredient: "р┤Хр╡Нр┤▓р╡Чр┤бр┤┐р╡╜ р┤ир┤┐р┤ир╡Нр┤ир╡Н р┤Ър╡Зр┤░р╡Бр┤╡ р┤ир╡Ар┤Хр╡Нр┤Хр┤В р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    failedToClearIngredients: "р┤Хр╡Нр┤▓р╡Чр┤бр┤┐р┤▓р╡Ж р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛ р┤ор┤╛р┤пр╡Нр┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    securityCheckNotReady: "р┤╕р╡Бр┤░р┤Хр╡Нр┤╖р┤╛ р┤кр┤░р┤┐р┤╢р╡Лр┤зр┤и р┤др┤пр╡Нр┤пр┤╛р┤▒р┤▓р╡Нр┤▓. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    firebaseAuthNotInitialized: "р┤лр┤пр╡╝р┤мр╡Зр┤╕р╡Н р┤Ур┤др┤ир╡Нр┤▒р┤┐р┤Хр╡Нр┤Хр╡Зр┤╖р╡╗ р┤Жр┤░р┤Вр┤нр┤┐р┤Ър╡Нр┤Ър┤┐р┤Яр╡Нр┤Яр┤┐р┤▓р╡Нр┤▓.",
    pleaseSendOtpFirst: "р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤Жр┤жр╡Нр┤пр┤В OTP р┤Ер┤пр┤Хр╡Нр┤Хр╡Бр┤Х.",
    enterVerificationCodeError: "р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤╕р╡Нр┤ер┤┐р┤░р╡Ар┤Хр┤░р┤г р┤Хр╡Лр┤бр╡Н р┤ир╡╜р┤Хр╡Бр┤ХуАВ", // Used for error message
    otpExpired: "р┤▒р╡Ар┤Хр┤╛р┤кр╡Нр┤Ър┤пр╡Бр┤Яр╡Ж р┤Хр┤╛р┤▓р┤╛р┤╡р┤зр┤┐ р┤Хр┤┤р┤┐р┤Юр╡Нр┤Юр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ OTP р┤╡р╡Ар┤гр╡Нр┤Яр╡Бр┤В р┤Ер┤пр┤Хр╡Нр┤Хр┤╛р╡╗ р┤╢р╡Нр┤░р┤ор┤┐р┤Хр╡Нр┤Хр╡Бр┤Х.",
    failedToLoadSecurity: "р┤╕р╡Бр┤░р┤Хр╡Нр┤╖р┤╛ р┤кр┤░р┤┐р┤╢р╡Лр┤зр┤и р┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир┤др┤┐р╡╜ р┤кр┤░р┤╛р┤Ьр┤пр┤кр╡Нр┤кр╡Жр┤Яр╡Нр┤Яр╡Б. р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤▒р╡Ар┤лр╡Нр┤░р┤╖р╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ХуАВ",
    translatingContent: "р┤Йр┤│р╡Нр┤│р┤Яр┤Хр╡Нр┤Хр┤В р┤▓р╡Лр┤бр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤ир╡Б",
    yourDish: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤╡р┤┐р┤нр┤╡р┤В",
    addSomeIngredients: "р┤др╡Бр┤Яр┤Щр╡Нр┤Щр┤╛р╡╗ р┤Ър┤┐р┤▓ р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛ р┤Ър╡Зр╡╝р┤Хр╡Нр┤Хр╡Бр┤Х!",
    noDescription: "р┤И р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр┤┐р┤ир╡Н р┤╡р┤┐р┤╡р┤░р┤гр┤В р┤▓р┤нр╡Нр┤пр┤ор┤▓р╡Нр┤▓.",
    recipe: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н",
    backToRecipes: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Бр┤Хр┤│р┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤др┤┐р┤░р┤┐р┤Хр╡Ж",
    defaultCuisine: "р┤╕р╡Нр┤ер┤┐р┤░р┤╕р╡Нр┤ер┤┐р┤др┤┐ р┤кр┤╛р┤Ър┤Хр┤░р╡Ар┤др┤┐", // New translation key
    backToDetails: "р┤╡р┤┐р┤╡р┤░р┤Щр╡Нр┤Щр┤│р┤┐р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤др┤┐р┤░р┤┐р┤Хр╡Ж", // New translation for procedure screen
    substitute: "р┤кр┤Хр┤░р┤ор╡Бр┤│р╡Нр┤│р┤др╡Н", // New translation key
    ingredientSubstitutions: "р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛р┤Хр╡Нр┤Хр╡Н р┤кр┤Хр┤░р┤ор╡Бр┤│р╡Нр┤│р┤╡", // New translation key
    creativeRecipeIdea: "р┤Хр╡Нр┤░р┤┐р┤пр╡Зр┤▒р╡Нр┤▒р╡Ар┤╡р╡Н р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н р┤Жр┤╢р┤пр┤В", // New translation key
    generateCreativeIdea: "р┤Хр╡Нр┤░р┤┐р┤пр┤╛р┤др╡Нр┤ор┤Х р┤Жр┤╢р┤пр┤В р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤Х", // New translation key
    recipeName: "р┤кр┤╛р┤Ър┤Хр┤Хр╡Нр┤Хр╡Бр┤▒р┤┐р┤кр╡Нр┤кр╡Н р┤кр╡Зр┤░р╡Н", // New translation key
    keyIngredients: "р┤кр╡Нр┤░р┤зр┤╛р┤и р┤Ър╡Зр┤░р╡Бр┤╡р┤Хр╡╛", // New translation key
    close: "р┤Ер┤Яр┤пр╡Нр┤Хр╡Нр┤Хр╡Бр┤Х", // New translation key
    generatingIdea: "р┤Жр┤╢р┤пр┤В р┤Йр┤гр╡Нр┤Яр┤╛р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б...", // New translation key
    findingSubstitutions: "р┤кр┤Хр┤░р┤ор╡Бр┤│р╡Нр┤│р┤╡ р┤Хр┤гр╡Нр┤Яр╡Жр┤др╡Нр┤др╡Бр┤ир╡Нр┤ир╡Б...", // New translation key
    shortProcedure: "р┤Ър╡Бр┤░р╡Бр┤Хр╡Нр┤Хр┤┐р┤п р┤ир┤Яр┤кр┤Яр┤┐р┤Хр╡Нр┤░р┤ор┤В", // New translation key
    noIdeaGenerated: "р┤Тр┤░р╡Б р┤Жр┤╢р┤пр┤╡р╡Бр┤В р┤╕р╡Гр┤╖р╡Нр┤Яр┤┐р┤Ър╡Нр┤Ър┤┐р┤▓р╡Нр┤▓.", // New translation key
    noSuggestionsFound: "р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤Щр╡Нр┤Щр┤│р╡Кр┤ир╡Нр┤ир╡Бр┤В р┤Хр┤гр╡Нр┤Яр╡Жр┤др╡Нр┤др┤┐р┤пр┤┐р┤▓р╡Нр┤▓.", // New translation key
  },
  te: { // Telugu
    welcomeBack: "р░др░┐р░░р░┐р░Чр░┐ р░╕р▒Нр░╡р░╛р░Чр░др░В!",
    createAccount: "р░Цр░╛р░др░╛р░ир▒Б р░╕р▒Гр░╖р▒Нр░Яр░┐р░Вр░Ър░Вр░бр░┐",
    loginWithPhone: "р░лр▒Лр░ир▒Н р░жр▒Нр░╡р░╛р░░р░╛ р░▓р░╛р░Чр░┐р░ир▒Н р░Ър▒Зр░пр░Вр░бр░┐",
    loginWithGoogle: "р░Чр▒Вр░Чр▒Бр░▓р▒Н р░жр▒Нр░╡р░╛р░░р░╛ р░▓р░╛р░Чр░┐р░ир▒Н р░Ър▒Зр░пр░Вр░бр░┐", // New translation key
    email: "р░Зр░ор▒Жр░пр░┐р░▓р▒Н",
    password: "р░кр░╛р░╕р▒НтАМр░╡р░░р▒Нр░бр▒Н",
    loginWithEmail: "р░Зр░ор▒Жр░пр░┐р░▓р▒Н р░жр▒Нр░╡р░╛р░░р░╛ р░▓р░╛р░Чр░┐р░ир▒Н р░Ър▒Зр░пр░Вр░бр░┐",
    dontHaveAccount: "р░Цр░╛р░др░╛ р░▓р▒Зр░жр░╛?",
    signUp: "р░╕р▒Ир░ир▒Н р░Ер░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐",
    alreadyHaveAccount: "р░Зр░кр▒Нр░кр░Яр░┐р░Хр▒З р░Цр░╛р░др░╛ р░Йр░Вр░жр░╛?",
    backToEmailLogin: "р░Зр░ор▒Жр░пр░┐р░▓р▒Н р░▓р░╛р░Чр░┐р░ир▒НтАМр░Хр▒Б р░др░┐р░░р░┐р░Чр░┐",
    enterPhoneNumber: "р░лр▒Лр░ир▒Н р░ир░Вр░мр░░р▒Н р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ (р░Йр░жр░╛: +919876543210)",
    sendOtp: "OTP р░кр░Вр░кр░Вр░бр░┐",
    enterVerificationCode: "р░зр▒Гр░╡р▒Ар░Хр░░р░г р░Хр▒Лр░бр▒НтАМр░ир▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐", // Used for placeholder
    verifyOtp: "OTP р░ир░┐ р░зр▒Гр░╡р▒Ар░Хр░░р░┐р░Вр░Ър░Вр░бр░┐",
    otpSent: "р░ор▒А р░лр▒Лр░ир▒НтАМр░Хр▒Б OTP р░кр░Вр░кр░мр░бр░┐р░Вр░жр░┐!",
    whatsInKitchen: "р░ор▒А р░╡р░Вр░Яр░Чр░жр░┐р░▓р▒Л р░Пр░ор▒Бр░Вр░жр░┐?",
    enterIngredient: "р░кр░жр░╛р░░р▒Нр░ер░В р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ (р░Йр░жр░╛: 'р░Ър░┐р░Хр▒Жр░ир▒Н', 'р░мр░┐р░пр▒Нр░пр░В')",
    addIngredient: "р░кр░жр░╛р░░р▒Нр░ер░В р░Ьр▒Лр░бр░┐р░Вр░Ър░Вр░бр░┐",
    yourIngredients: "р░ор▒А р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р▒Б:",
    clearAll: "р░Ер░ир▒Нр░ир░┐р░Вр░Яр░┐р░ир▒А р░Хр▒Нр░▓р░┐р░пр░░р▒Н р░Ър▒Зр░пр░Вр░бр░┐",
    selectCuisine: "р░╡р░Вр░Яр░Хр░В р░Ор░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐ (р░Рр░Ър▒Нр░Ыр░┐р░Хр░В):",
    anyCuisine: "р░П р░╡р░Вр░Яр░Хр░В р░Ер░пр░┐р░ир░╛",
    findRecipes: "р░╡р░Вр░Яр░Хр░╛р░▓р░ир▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░Вр░бр░┐",
    recommendedRecipes: "р░╕р░┐р░лр░╛р░░р▒Нр░╕р▒Б р░Ър▒Зр░пр░мр░бр░┐р░и р░╡р░Вр░Яр░Хр░╛р░▓р▒Б",
    backToIngredients: "р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р░Хр▒Б р░др░┐р░░р░┐р░Чр░┐",
    ingredients: "р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р▒Б",
    description: "р░╡р░┐р░╡р░░р░г",
    startCookingProcedure: "р░╡р░Вр░Я р░╡р░┐р░зр░╛р░ир░╛р░ир▒Нр░ир░┐ р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░Вр░бр░┐",
    copyRecipe: "р░╡р░Вр░Яр░Хр░╛р░ир▒Нр░ир░┐ р░Хр░╛р░кр▒А р░Ър▒Зр░пр░Вр░бр░┐",
    copied: "р░Хр░╛р░кр▒А р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐!",
    cookingProcedure: "р░╡р░Вр░Я р░╡р░┐р░зр░╛р░ир░В",
    step: "р░жр░╢",
    previousStep: "р░ор▒Бр░ир▒Бр░кр░Яр░┐ р░жр░╢",
    nextStep: "р░др░жр▒Бр░кр░░р░┐ р░жр░╢",
    finishCooking: "р░╡р░Вр░Я р░кр▒Вр░░р▒Нр░др░┐ р░Ър▒Зр░пр░Вр░бр░┐!",
    congratulations: "ЁЯОЙ р░Ер░нр░┐р░ир░Вр░жр░ир░▓р▒Б! ЁЯОЙ",
    recipeCompleted: "р░ор▒Ар░░р▒Б р░╡р░Вр░Яр░Хр░╛р░ир▒Нр░ир░┐ р░╡р░┐р░Ьр░пр░╡р░Вр░др░Вр░Чр░╛ р░кр▒Вр░░р▒Нр░др░┐ р░Ър▒Зр░╕р░╛р░░р▒Б:",
    cookAnotherRecipe: "р░ор░░р▒Кр░Х р░╡р░Вр░Яр░Хр░В р░╡р░Вр░бр░Вр░бр░┐",
    logout: "р░▓р░╛р░Чр▒Н р░Ер░╡р▒Бр░Яр▒Н",
    loadingApp: "р░пр░╛р░кр▒Н р░▓р▒Лр░бр▒Н р░Ер░╡р▒Бр░др▒Лр░Вр░жр░┐...",
    error: "р░▓р▒Лр░кр░В:",
    pleaseAddIngredient: "р░╡р░Вр░Яр░Хр░╛р░▓р░ир▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░бр░╛р░ир░┐р░Хр░┐ р░жр░пр░Ър▒Зр░╕р░┐ р░Хр░ир▒Ар░╕р░В р░Тр░Х р░кр░жр░╛р░░р▒Нр░ер░╛р░ир▒Нр░ир░┐ р░Ьр▒Лр░бр░┐р░Вр░Ър░Вр░бр░┐.",
    failedToFetchRecipes: "р░╡р░Вр░Яр░Хр░╛р░▓р░ир▒Б р░кр▒Кр░Вр░жр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐:",
    noRecipesFound: "р░ор▒А р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р▒Б р░ор░░р░┐р░пр▒Б р░╡р░Вр░Яр░Хр░╛р░ир░┐р░Хр░┐ р░╡р░Вр░Яр░Хр░╛р░▓р▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░▓р▒Зр░жр▒Б. р░ор░░р░┐р░ир▒Нр░ир░┐ р░Ьр▒Лр░бр░┐р░Вр░Ър░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░╡р░Вр░Яр░Хр░╛р░ир▒Нр░ир░┐ р░ор░╛р░░р▒Нр░Ър░Вр░бр░┐!",
    settings: "р░╕р▒Жр░Яр▒Нр░Яр░┐р░Вр░Чр▒НтАМр░▓р▒Б",
    language: "р░нр░╛р░╖",
    popularDishes: "р░кр▒Нр░░р░╕р░┐р░жр▒Нр░з р░╡р░Вр░Яр░Хр░╛р░▓р▒Б",
    viewPopularDishes: "р░кр▒Нр░░р░╕р░┐р░жр▒Нр░з р░╡р░Вр░Яр░Хр░╛р░▓р░ир▒Б р░Ър▒Вр░бр░Вр░бр░┐",
    backToHome: "р░╣р▒Лр░ор▒НтАМр░Хр▒Б р░др░┐р░░р░┐р░Чр░┐",
    noInstructions: "р░И р░╡р░Вр░Яр░Хр░╛р░ир░┐р░Хр░┐ р░╡р░┐р░╡р░░р░гр░╛р░др▒Нр░ор░Х р░╕р▒Вр░Ър░ир░▓р▒Б р░Ер░Вр░жр▒Бр░мр░╛р░Яр▒Бр░▓р▒Л р░▓р▒Зр░╡р▒БуАВ",
    failedToClearIngredients: "р░Хр▒Нр░▓р▒Мр░бр▒НтАМр░▓р▒Лр░ир░┐ р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р░ир▒Б р░Хр▒Нр░▓р░┐р░пр░░р▒Н р░Ър▒Зр░пр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░│р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐уАВ",
    securityCheckNotReady: "р░нр░жр▒Нр░░р░др░╛ р░др░ир░┐р░Цр▒А р░╕р░┐р░жр▒Нр░зр░Вр░Чр░╛ р░▓р▒Зр░жр▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░│р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐уАВ",
    firebaseAuthNotInitialized: "р░лр▒Ир░░р▒НтАМр░мр▒Зр░╕р▒Н р░кр▒Нр░░р░ор░╛р░гр▒Ар░Хр░░р░г р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░мр░бр░▓р▒Зр░жр▒БуАВ",
    pleaseSendOtpFirst: "р░жр░пр░Ър▒Зр░╕р░┐ р░ор▒Бр░Вр░жр▒Бр░Чр░╛ OTP р░кр░Вр░кр░Вр░бр░┐уАВ",
    enterVerificationCodeError: "р░жр░пр░Ър▒Зр░╕р░┐ р░зр▒Гр░╡р▒Ар░Хр░░р░г р░Хр▒Лр░бр▒НтАМр░ир▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐уАВ", // Used for error message
    otpExpired: "р░░р▒Ар░Хр▒Нр░пр░╛р░кр▒Нр░Ър░╛ р░Чр░бр▒Бр░╡р▒Б р░ор▒Бр░Чр░┐р░╕р░┐р░Вр░жр░┐. р░жр░пр░Ър▒Зр░╕р░┐ OTP р░ир░┐ р░ор░│р▒Нр░│р▒А р░кр░Вр░кр░бр░╛р░ир░┐р░Хр░┐ р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐уАВ",
    failedToLoadSecurity: "р░нр░жр▒Нр░░р░др░╛ р░др░ир░┐р░Цр▒Ар░ир░┐ р░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐. р░жр░пр░Ър▒Зр░╕р░┐ р░░р░┐р░лр▒Нр░░р▒Жр░╖р▒Н р░Ър▒Зр░пр░Вр░бр░┐уАВ",
    translatingContent: "р░Хр░Вр░Яр▒Жр░Вр░Яр▒Н р░Ер░ир▒Бр░╡р░жр░┐р░╕р▒Нр░др▒Лр░Вр░жр░┐",
    yourDish: "р░ор▒А р░бр░┐р░╖р▒Н",
    addSomeIngredients: "р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░бр░╛р░ир░┐р░Хр░┐ р░Хр▒Кр░ир▒Нр░ир░┐ р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р░ир▒Б р░Ьр▒Лр░бр░┐р░Вр░Ър░Вр░бр░┐!",
    noDescription: "р░И р░╡р░Вр░Яр░Хр░╛р░ир░┐р░Хр░┐ р░╡р░┐р░╡р░░р░г р░Ер░Вр░жр▒Бр░мр░╛р░Яр▒Бр░▓р▒Л р░▓р▒Зр░жр▒БуАВ",
    recipe: "р░╡р░Вр░Яр░Хр░В",
    backToRecipes: "р░╡р░Вр░Яр░Хр░╛р░▓р░Хр▒Б р░др░┐р░░р░┐р░Чр░┐",
    defaultCuisine: "р░бр░┐р░лр░╛р░▓р▒Нр░Яр▒Н р░╡р░Вр░Яр░Хр░В", // New translation key
    backToDetails: "р░╡р░┐р░╡р░░р░╛р░▓р░Хр▒Б р░др░┐р░░р░┐р░Чр░┐", // New translation for procedure screen
    substitute: "р░кр▒Нр░░р░др▒Нр░пр░╛р░ор▒Нр░ир░╛р░пр░В", // New translation key
    ingredientSubstitutions: "р░кр░жр░╛р░░р▒Нр░е р░кр▒Нр░░р░др▒Нр░пр░╛р░ор▒Нр░ир░╛р░пр░╛р░▓р▒Б", // New translation key
    creativeRecipeIdea: "р░Хр▒Нр░░р░┐р░пр▒Зр░Яр░┐р░╡р▒Н р░╡р░Вр░Яр░Хр░В р░Жр░▓р▒Лр░Ър░и", // New translation key
    generateCreativeIdea: "р░Хр▒Нр░░р░┐р░пр▒Зр░Яр░┐р░╡р▒Н р░Жр░▓р▒Лр░Ър░ир░ир▒Б р░░р▒Вр░кр▒Кр░Вр░жр░┐р░Вр░Ър░Вр░бр░┐", // New translation key
    recipeName: "р░╡р░Вр░Яр░Хр░В р░кр▒Зр░░р▒Б", // New translation key
    keyIngredients: "р░Хр▒А р░кр░жр░╛р░░р▒Нр░ер░╛р░▓р▒Б", // New translation key
    close: "р░ор▒Вр░╕р░┐р░╡р▒Зр░пр░┐", // New translation key
    generatingIdea: "р░Жр░▓р▒Лр░Ър░ир░ир▒Б р░░р▒Вр░кр▒Кр░Вр░жр░┐р░╕р▒Нр░др▒Бр░Вр░жр░┐...", // New translation key
    findingSubstitutions: "р░кр▒Нр░░р░др▒Нр░пр░╛р░ор▒Нр░ир░╛р░пр░╛р░▓р░ир▒Б р░Хр░ир▒Бр░Чр▒Кр░Вр░Яр▒Бр░Вр░жр░┐...", // New translation key
    shortProcedure: "р░Ър░┐р░ир▒Нр░и р░╡р░┐р░зр░╛р░ир░В", // New translation key
    noIdeaGenerated: "р░Жр░▓р▒Лр░Ър░и р░░р▒Вр░кр▒Кр░Вр░жр░┐р░Вр░Ър░мр░бр░▓р▒Зр░жр▒Б.", // New translation key
    noSuggestionsFound: "р░╕р▒Вр░Ър░ир░▓р▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░▓р▒Зр░жр▒Б.", // New translation key
  },
};


// CSS for custom animations (fadeIn, steam, stir, confetti)
const customAnimationsCss = `
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes steam {
  0% { transform: translateY(0px) translateX(0px); opacity: 0.8; }
  25% { transform: translateY(-5px) translateX(2px); opacity: 0.6; }
  50% { transform: translateY(-10px) translateX(-2px); opacity: 0.4; }
  75% { transform: translateY(-15px) translateX(2px); opacity: 0.2; }
  100% { transform: translateY(-20px) translateX(-2px); opacity: 0; }
}

@keyframes stir {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes confetti-fall {
  0% {
    transform: translateY(-100vh) rotate(0deg);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

.animate-fadeIn {
  animation: fadeIn 0.5s ease-out forwards;
}
.animate-steam {
  animation: steam 1.5s infinite ease-out;
}
.delay-100 {
  animation-delay: 0.1s;
}
.animate-stir {
  animation: stir 2s linear infinite;
  transform-origin: 50% 50%; /* Center of the pot */
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: var(--confetti-color);
  animation: confetti-fall var(--animation-duration) ease-out forwards;
  opacity: 0;
  border-radius: 50%;
  box-shadow: 0 0 5px rgba(0,0,0,0.2);
  z-index: 9999; /* Ensure confetti is on top */
}
.animate-bounce-in {
  animation: bounceIn 0.8s ease-out;
}
@keyframes bounceIn {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.05); opacity: 1; }
  70% { transform: scale(0.9); }
  100% { transform: scale(1); }
}
`;

// Loading Skeleton Component
const RecipeCardSkeleton = () => (
  <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-xl overflow-hidden mb-6 w-full shadow-xl animate-pulse border-2 border-gray-200 border-opacity-60">
    <div className="w-full h-56 bg-gray-300"></div>
    <div className="p-5">
      <div className="h-6 bg-gray-300 rounded w-3/4 mb-2"></div>
      <div className="h-4 bg-gray-300 rounded w-full mb-3"></div>
      <div className="h-4 bg-gray-300 rounded w-1/2"></div>
    </div>
  </div>
);

// Cooking Animation Component
const CookingAnimation = ({ step }) => {
  let svgContent = null;
  const animationType = step % 4; // Cycles through 4 animation types

  switch (animationType) {
    case 0: // Initial/Prep/Chopping
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <rect x="10" y="70" width="80" height="20" fill="#8B4513" rx="5" ry="5" /> {/* Cutting board */}
          <path d="M 70 60 L 60 80 L 80 80 Z" fill="#32CD32" /> {/* Veggie piece 1 */}
          <path d="M 50 65 L 40 75 L 60 75 Z" fill="#FFD700" /> {/* Veggie piece 2 */}
          <path d="M 40 50 L 35 70 L 55 70 Z" fill="#FF6347" /> {/* Veggie piece 3 */}
          <line x1="85" y1="50" x2="75" y2="70" stroke="#A9A9A9" strokeWidth="3" strokeLinecap="round" /> {/* Knife handle */}
          <line x1="75" y1="70" x2="65" y2="70" stroke="#D3D3D3" strokeWidth="3" strokeLinecap="round" /> {/* Knife blade */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Prepare Ingredients</text>
        </svg>
      );
      break;
    case 1: // Heating/Frying/Saut├йing
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <rect x="25" y="60" width="50" height="20" fill="#A9A9A9" rx="5" ry="5" /> {/* Stove top */}
          <circle cx="50" cy="50" r="20" fill="#D3D3D3" stroke="#808080" strokeWidth="2" /> {/* Pan */}
          <circle cx="50" cy="50" r="15" fill="#FF8C00" /> {/* Heat/Oil */}
          <path d="M 50 30 Q 55 20 60 30" stroke="#fff" strokeWidth="2" fill="none" className="animate-steam" /> {/* Steam 1 */}
          <path d="M 40 35 Q 45 25 50 35" stroke="#fff" strokeWidth="2" fill="none" className="animate-steam delay-100" /> {/* Steam 2 */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Heat & Cook</text>
        </svg>
      );
      break;
    case 2: // Stirring/Mixing
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="50" r="25" fill="#A9A9A9" stroke="#808080" strokeWidth="2" /> {/* Pot */}
          <rect x="40" y="75" width="20" height="5" fill="#8B4513" /> {/* Pot handle */}
          <path d="M 60 40 L 70 30 L 80 40" stroke="#8B4513" strokeWidth="3" strokeLinecap="round" /> {/* Spoon handle */}
          <circle cx="80" cy="40" r="5" fill="#8B4513" /> {/* Spoon head */}
          <animateTransform
            attributeName="transform"
            attributeType="XML"
            type="rotate"
            from="0 50 50"
            to="360 50 50"
            dur="2s"
            repeatCount="indefinite"
            className="animate-stir"
          />
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Stirring</text>
        </svg>
      );
      break;
    case 3: // Serving/Dish Ready
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="70" r="30" fill="#fff" stroke="#ccc" strokeWidth="2" /> {/* Plate */}
          <path d="M 30 60 Q 50 30 70 60 Q 50 90 30 60 Z" fill="#FFD700" stroke="#FF8C00" strokeWidth="2" /> {/* Food */}
          <path d="M 40 65 Q 50 40 60 65" fill="#32CD32" /> {/* Garnish */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Dish Ready!</text>
        </svg>
      );
      break;
    default: // Fallback for any other step, maybe a generic cooking icon
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="50" r="40" fill="#eee" stroke="#ccc" strokeWidth="2" />
          <path d="M 30 50 L 70 50 M 50 30 L 50 70" stroke="#aaa" strokeWidth="5" strokeLinecap="round" />
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Cooking Action</text>
        </svg>
      );
  }

  return (
    <div className="w-full h-full flex items-center justify-center">
      {svgContent}
    </div>
  );
};


const App = () => {
  const [currentScreen, setCurrentScreen] = useState(SCREENS.LOGIN); // Start at login screen
  const [ingredientsInput, setIngredientsInput] = useState('');
  const [userIngredients, setUserIngredients] = useState([]);
  const [recommendedRecipes, setRecommendedRecipes] = useState([]);
  const [selectedRecipe, setSelectedRecipe] = useState(null); // Corrected: Initialized with useState(null)
  const [loading, setLoading] = useState(false);
  const [currentProcedureStep, setCurrentProcedureStep] = useState(0);
  const [apiError, setApiError] = useState(null);
  const [selectedCuisine, setSelectedCuisine] = useState(''); // Default to empty string for "Any Cuisine"
  const [showCopiedMessage, setShowCopiedMessage] = useState(false);
  const [translationLoading, setTranslationLoading] = useState(false); // New state for translation loading

  // Firebase Auth States
  const [currentUser, setCurrentUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [authError, setAuthError] = useState(null);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Phone Auth States
  const [phoneNumber, setPhoneNumber] = useState('');
  const [verificationCode, setVerificationCode] = useState('');
  const [confirmationResult, setConfirmationResult] = useState(null); // Stores the result of sending OTP
  const recaptchaRef = useRef(null); // Ref for Recaptcha container
  const [recaptchaVerifier, setRecaptchaVerifier] = useState(null); // Stores the RecaptchaVerifier instance
  const [showOtpSentMessage, setShowOtpSentMessage] = useState(false); // New state for OTP sent message

  // LLM Feature States
  const [showSubstitutionModal, setShowSubstitutionModal] = useState(false);
  const [substitutionResult, setSubstitutionResult] = null;
  const [substitutingIngredient, setSubstitutingIngredient] = useState('');
  const [showCreativeRecipeModal, setShowCreativeRecipeModal] = useState(false);
  const [creativeRecipeIdea, setCreativeRecipeIdea] = useState(null);
  const [llmLoading, setLlmLoading] = useState(false); // Combined loading for LLM features

  // For animation, we'll use a simple CSS transition via state for opacity
  const [stepOpacity, setStepOpacity] = useState(1);
  const confettiContainerRef = useRef(null); // Ref for confetti container

  // Use useState for app, auth, and db instances to ensure they are reactive
  const [appInstance, setAppInstance] = useState(null);
  const [authInstance, setAuthInstance] = useState(null);
  const [dbInstance, setDbInstance] = useState(null);

  // New state for language selection, default to English
  const [language, setLanguage] = useState('en');

  // Helper function to get translated text
  const getTranslatedText = (key) => {
    return translations[language]?.[key] || translations.en[key] || key;
  };

  // Firebase Configuration - YOUR ACTUAL CONFIG IS HERE!
  // REPLACE THESE VALUES WITH YOUR PROJECT'S CONFIG FROM FIREBASE CONSOLE
  const firebaseConfig = {
    apiKey: "AIzaSyC-dFXiWiQXctEvSZPPPwVb_WEIsz-DGmc",
    authDomain: "curry-craft-daf8f.firebaseapp.com",
    projectId: "curry-craft-daf8f",
    storageBucket: "curry-craft-daf8f.firebasestorage.app",
    messagingSenderId: "905032476877",
    appId: "1:905032476877:web:1d5434f1fcbc86532fe184",
    measurementId: "G-VX5E06M3TN"
  };

  // Firebase Initialization and Auth Listener
  useEffect(() => {
    try {
      const initializedApp = initializeApp(firebaseConfig);
      const initializedAuth = getAuth(initializedApp);
      const initializedDb = getFirestore(initializedApp);

      setAppInstance(initializedApp);
      setAuthInstance(initializedAuth);
      setDbInstance(initializedDb);

      const unsubscribe = onAuthStateChanged(initializedAuth, async (user) => {
        if (user) {
          setCurrentUser(user);
          try {
            const userDocRef = doc(initializedDb, "users", user.uid);
            const userDocSnap = await getDoc(userDocRef);

            if (userDocSnap.exists()) {
              const userData = userDocSnap.data();
              setUserIngredients(userData.userIngredients || []);
              // Set user's preferred language if stored, otherwise default
              setLanguage(userData.preferences?.language || 'en');
              // Set user's preferred cuisine if stored, otherwise default to empty (Any Cuisine)
              setSelectedCuisine(userData.preferences?.cuisine || '');
              console.log("User data loaded from Firestore:", userData);
            } else {
              console.log("No existing user document found. Creating one.");
              await setDoc(userDocRef, {
                  email: user.email || user.phoneNumber || user.providerData[0]?.email || 'N/A', // Handle Google email
                  userIngredients: [],
                  savedRecipeIds: [],
                  preferences: { cuisine: '', language: 'en' }, // Default to Any Cuisine
                  createdAt: new Date()
              });
              setUserIngredients([]);
              setLanguage('en');
              setSelectedCuisine(''); // Set default cuisine on new user creation
            }
          } catch (firestoreError) {
            console.error("Error loading user data from Firestore:", firestoreError);
            setApiError(getTranslatedText("failedToLoadUserData"));
            setUserIngredients([]);
          }
          if ([SCREENS.LOGIN, SCREENS.SIGNUP, SCREENS.PHONE_LOGIN].includes(currentScreen)) {
            setCurrentScreen(SCREENS.HOME);
          }
        } else {
          setCurrentUser(null);
          setUserIngredients([]);
          setCurrentScreen(SCREENS.LOGIN);
          // --- CRITICAL FIX START ---
          // Attempt to sign in with custom token if available (for Canvas environment)
          // Otherwise, sign in anonymously. This ensures all users are authenticated for Firestore.
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            try {
              await signInWithCustomToken(initializedAuth, __initial_auth_token);
              console.log("Signed in with custom token.");
            } catch (tokenError) {
              console.error("Error signing in with custom token, falling back to anonymous:", tokenError);
              try {
                await signInAnonymously(initializedAuth);
                console.log("Signed in anonymously.");
              } catch (anonError) {
                console.error("Error signing in anonymously:", anonError);
                setAuthError("Authentication failed. Please try again.");
              }
            }
          } else {
            // If no custom token is provided (e.g., local development outside Canvas)
            try {
              await signInAnonymously(initializedAuth);
              console.log("Signed in anonymously (no custom token).");
            } catch (anonError) {
              console.error("Error signing in anonymously:", anonError);
              setAuthError("Authentication failed. Please try again.");
            }
          }
          // --- CRITICAL FIX END ---
        }
        setAuthLoading(false);
      });
      return () => unsubscribe();
    } catch (e) {
      console.error("Error initializing Firebase:", e);
      setAuthError(getTranslatedText("failedToInitAuth"));
      setAuthLoading(false);
      setCurrentScreen(SCREENS.HOME);
    }
  }, []);

  // Effect to update user's language and cuisine preference in Firestore
  useEffect(() => {
    if (currentUser && dbInstance) {
      const userDocRef = doc(dbInstance, "users", currentUser.uid);
      updateDoc(userDocRef, {
        'preferences.language': language,
        'preferences.cuisine': selectedCuisine // Persist selectedCuisine from Home/Settings
      }).catch(error => {
        console.error("Error updating user preferences:", error);
      });
    }
  }, [language, selectedCuisine, currentUser, dbInstance]);


  // Initialize RecaptchaVerifier when the phone login screen is active AND authInstance is available
  useEffect(() => {
    if (authInstance && currentScreen === SCREENS.PHONE_LOGIN && recaptchaRef.current && !recaptchaVerifier) {
      try {
        const verifier = new RecaptchaVerifier(authInstance, recaptchaRef.current, {
          'size': 'invisible',
          'callback': (response) => {
            console.log("Recaptcha solved!");
          },
          'expired-callback': () => {
            console.warn("Recaptcha expired.");
            setAuthError(getTranslatedText("otpExpired"));
            setRecaptchaVerifier(null);
          }
        });
        verifier.render().then((widgetId) => {
          console.log("Recaptcha rendered:", widgetId);
        });
        setRecaptchaVerifier(verifier);
      } catch (error) {
        console.error("Error initializing Recaptcha:", error);
        setAuthError(getTranslatedText("failedToLoadSecurity"));
      }
    }
  }, [authInstance, currentScreen, recaptchaVerifier, recaptchaRef, getTranslatedText]);


  useEffect(() => {
    if (currentScreen === SCREENS.PROCEDURE) {
      setStepOpacity(0);
      const timer = setTimeout(() => {
        setStepOpacity(1);
      }, 100);
      return () => clearTimeout(timer);
    }
    if (currentScreen === SCREENS.COMPLETED) {
      generateConfetti();
    }
  }, [currentProcedureStep, currentScreen]);

  // Function to generate confetti
  const generateConfetti = () => {
    if (!confettiContainerRef.current) return;

    const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];
    const numConfetti = 50;

    for (let i = 0; i < numConfetti; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.setProperty('--confetti-color', colors[Math.floor(Math.random() * colors.length)]);
      confetti.style.left = `${Math.random() * 100}vw`;
      confetti.style.top = `${Math.random() * -20}vh`;
      confetti.style.animationDuration = `${2 + Math.random() * 3}s`;
      confetti.style.animationDelay = `${Math.random() * 0.5}s`;
      confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

      confettiContainerRef.current.appendChild(confetti);

      confetti.addEventListener('animationend', () => {
        confetti.remove();
      });
    }
  };

  // LLM Translation Function
  const translateText = useCallback(async (content, targetLanguage) => {
    if (targetLanguage === 'en') {
      return content; // No translation needed for English
    }

    setTranslationLoading(true);
    let prompt;
    let responseSchema;

    // Handle string content (e.g., individual recipe parts)
    if (typeof content === 'string') {
      prompt = `Translate the following text into ${targetLanguage}. Provide only the translated text as a string, no other formatting or explanation.`;
      responseSchema = { type: "STRING" };
      content = { text: content }; // Wrap string in an object for consistent processing
    } else {
      // Handle object content (e.g., full recipe object)
      prompt = `Translate the following JSON object's string values into ${targetLanguage}. Ensure the output is a valid JSON object with the same keys. Do not include any other text or formatting outside the JSON.`;
      responseSchema = {
        type: "OBJECT",
        properties: {
          name: { type: "STRING" },
          description: { type: "STRING" },
          ingredients: { type: "ARRAY", items: { type: "STRING" } },
          procedure: { type: "ARRAY", items: { type: "STRING" } }
        }
      };
    }

    const chatHistory = [{ role: "user", parts: [{ text: `${prompt}\n\nOriginal: ${JSON.stringify(content)}` }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setTranslationLoading(false);
          return parsedResult;
        } catch (parseError) {
          console.error("Error parsing LLM response JSON:", parseError, "Raw text:", text);
          setTranslationLoading(false);
          return typeof content === 'string' ? content : content; // Return original content on JSON parse failure
        }
      } else {
        console.error("LLM translation failed: No candidates or content found.", result);
        setTranslationLoading(false);
        return typeof content === 'string' ? content : content; // Return original content on no candidates
      }
    } catch (llmError) {
      console.error("Error calling LLM for translation:", llmError);
      setTranslationLoading(false);
      return typeof content === 'string' ? content : content; // Return original content on fetch error
    }
  }, []);

  // LLM: Ingredient Substitution
  const handleIngredientSubstitution = async (ingredientName) => {
    setLlmLoading(true);
    setSubstitutionResult(null);
    setSubstitutingIngredient(ingredientName);

    const prompt = `What are some good substitutions for "${ingredientName}" in a recipe? Provide 2-3 common alternatives and a brief note on their use. Format as a JSON object with a 'substitutions' array, where each item is an object with 'name' and 'note' properties.`;
    const responseSchema = {
      type: "OBJECT",
      properties: {
        substitutions: {
          type: "ARRAY",
          items: {
            type: "OBJECT",
            properties: {
              name: { type: "STRING" },
              note: { type: "STRING" }
            }
          }
        }
      }
    };

    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setSubstitutionResult(parsedResult.substitutions || []);
        } catch (parseError) {
          console.error("Error parsing LLM substitution response JSON:", parseError, "Raw text:", text);
          setSubstitutionResult([{ name: "Error", note: "Could not parse substitution suggestions." }]);
        }
      } else {
        console.error("LLM substitution failed: No candidates or content found.", result);
        setSubstitutionResult([{ name: "No suggestions", note: "Could not find substitutions." }]);
      }
    } catch (llmError) {
      console.error("Error calling LLM for substitution:", llmError);
      setSubstitutionResult([{ name: "Error", note: "Failed to fetch substitutions." }]);
    } finally {
      setLlmLoading(false);
      setShowSubstitutionModal(true);
    }
  };

  // LLM: Generate Creative Recipe Idea
  const handleGenerateCreativeRecipeIdea = async () => {
    setLlmLoading(true);
    setCreativeRecipeIdea(null);
    setApiError(null); // Clear any previous API errors

    if (userIngredients.length === 0) {
      setApiError(getTranslatedText("pleaseAddIngredient"));
      setLlmLoading(false);
      return;
    }

    const ingredientsList = userIngredients.join(', ');
    const prompt = `Given the following ingredients: ${ingredientsList}, suggest a creative and unique recipe idea. Provide the recipe name, a brief description (3-5 sentences), a list of key ingredients (max 5), and a short, simple procedure (3-5 steps). Format as a JSON object with keys 'name' (string), 'description' (string), 'keyIngredients' (array of strings), and 'shortProcedure' (array of strings).`;
    const responseSchema = {
      type: "OBJECT",
      properties: {
        name: { type: "STRING" },
        description: { type: "STRING" },
        keyIngredients: { type: "ARRAY", items: { type: "STRING" } },
        shortProcedure: { type: "ARRAY", items: { type: "STRING" } }
      }
    };

    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setCreativeRecipeIdea(parsedResult);
        } catch (parseError) {
          console.error("Error parsing LLM creative idea response JSON:", parseError, "Raw text:", text);
          setCreativeRecipeIdea({ name: "Error", description: "Could not generate a creative idea.", keyIngredients: [], shortProcedure: [] });
        }
      } else {
        console.error("LLM creative idea failed: No candidates or content found.", result);
        setCreativeRecipeIdea({ name: "No Idea", description: "Could not generate a creative idea based on your ingredients.", keyIngredients: [], shortProcedure: [] });
      }
    } catch (llmError) {
      console.error("Error calling LLM for creative idea:", llmError);
      setCreativeRecipeIdea({ name: "Error", description: "Failed to generate a creative idea.", keyIngredients: [], shortProcedure: [] });
    } finally {
      setLlmLoading(false);
      setShowCreativeRecipeModal(true);
    }
  };


  // Auth Handlers
  const handleLogin = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      await signInWithEmailAndPassword(authInstance, email, password);
    } catch (error) {
      console.error("Login failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  const handleSignup = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      const userCredential = await createUserWithEmailAndPassword(authInstance, email, password);
      const user = userCredential.user;

      if (dbInstance) {
          await setDoc(doc(dbInstance, "users", user.uid), {
              email: user.email,
              userIngredients: [],
              savedRecipeIds: [],
              preferences: { cuisine: '', language: language }, // Default to Any Cuisine
              createdAt: new Date()
          });
          console.log("New user document created in Firestore.");
      }
    } catch (error) {
      console.error("Signup failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(authInstance, provider);
      const user = result.user;

      // Check if user data exists in Firestore, if not, create it
      if (dbInstance) {
        const userDocRef = doc(dbInstance, "users", user.uid);
        const userDocSnap = await getDoc(userDocRef);

        if (!userDocSnap.exists()) {
          await setDoc(userDocRef, {
            email: user.email,
            userIngredients: [],
            savedRecipeIds: [],
            preferences: { cuisine: '', language: language }, // Default to Any Cuisine
            createdAt: new Date()
          });
          console.log("New user document created in Firestore for Google login.");
        } else {
          console.log("Existing user document found for Google login.");
        }
      }
    } catch (error) {
      console.error("Google login failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };


  const handleSendOtp = async () => {
    setAuthLoading(true);
    setAuthError(null);
    if (!phoneNumber) {
      setAuthError(getTranslatedText("enterPhoneNumber"));
      setAuthLoading(false);
      return;
    }
    if (!recaptchaVerifier) {
      setAuthError(getTranslatedText("securityCheckNotReady"));
      setAuthLoading(false);
      return;
    }
    if (!authInstance) {
      setAuthError(getTranslatedText("firebaseAuthNotInitialized"));
      setAuthLoading(false);
      return;
    }

    try {
      const result = await signInWithPhoneNumber(authInstance, phoneNumber, recaptchaVerifier);
      setConfirmationResult(result);
      setAuthError(null);
      setShowOtpSentMessage(true);
      setTimeout(() => setShowOtpSentMessage(false), 3000); // Hide after 3 seconds
    } catch (error) {
      console.error("Error sending OTP:", error);
      setAuthError(error.message);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } finally {
      setAuthLoading(false);
    }
  };

  const handleVerifyOtp = async () => {
    setAuthLoading(true);
    setAuthError(null);
    if (!confirmationResult) {
      setAuthError(getTranslatedText("pleaseSendOtpFirst"));
      setAuthLoading(false);
      return;
    }
    if (!verificationCode) {
      setAuthError(getTranslatedText("enterVerificationCodeError")); // Corrected key
      setAuthLoading(false);
      return;
    }

    try {
      await confirmationResult.confirm(verificationCode);
      setAuthError(null);
      setPhoneNumber('');
      setVerificationCode('');
      setConfirmationResult(null);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } catch (error) {
      console.error("Error verifying OTP:", error);
      setAuthError(error.message);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } finally {
      setAuthLoading(false);
    }
  };

  const handleLogout = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      await signOut(authInstance);
    } catch (error) {
      console.error("Logout failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  // Recipe App Handlers
  const handleAddIngredient = async () => {
    const trimmedInput = ingredientsInput.trim();
    if (trimmedInput && !userIngredients.includes(trimmedInput.toLowerCase())) {
      const newIngredient = trimmedInput.toLowerCase();
      const updatedIngredients = [...userIngredients, newIngredient];

      setUserIngredients(updatedIngredients);
      setIngredientsInput('');

      if (currentUser && dbInstance) {
          const userDocRef = doc(dbInstance, "users", currentUser.uid);
          try {
              await updateDoc(userDocRef, {
                  userIngredients: arrayUnion(newIngredient)
              });
              console.log("Ingredient saved to Firestore successfully!");
          } catch (error) {
              console.error("Error saving ingredient to Firestore:", error);
              alert(getTranslatedText("failedToSaveIngredient"));
              setUserIngredients(userIngredients);
          }
      } else {
          console.warn("Not logged in or Firestore not initialized, cannot save ingredient to cloud.");
      }
    }
  };

  const handleRemoveIngredient = async (ingredientToRemove) => {
    const updatedIngredients = userIngredients.filter(ing => ing !== ingredientToRemove);
    setUserIngredients(updatedIngredients);

    if (currentUser && dbInstance) {
        const userDocRef = doc(dbInstance, "users", currentUser.uid);
        try {
            await updateDoc(userDocRef, {
                userIngredients: arrayRemove(ingredientToRemove)
            });
            console.log("Ingredient removed from Firestore successfully!");
        } catch (error) {
            console.error("Error removing ingredient from Firestore:", error);
            alert(getTranslatedText("failedToRemoveIngredient"));
            setUserIngredients(userIngredients);
        }
    } else {
        console.warn("Not logged in or Firestore not initialized, cannot remove ingredient from cloud.");
    }
  };

  const handleClearAllIngredients = async () => {
    setUserIngredients([]);

    if (currentUser && dbInstance) {
        const userDocRef = doc(dbInstance, "users", currentUser.uid);
        try {
            await updateDoc(userDocRef, {
                userIngredients: []
            });
            console.log("All ingredients cleared in Firestore!");
        } catch (error) {
            console.error("Error clearing ingredients in Firestore:", error);
            alert(getTranslatedText("failedToClearIngredients"));
        }
    } else {
        console.warn("Not logged in or Firestore not initialized, cannot clear ingredients in cloud.");
    }
  };

  const fetchRecipes = async (type = 'ingredients') => {
    setLoading(true);
    setRecommendedRecipes([]);
    setApiError(null);
    setTranslationLoading(false); // Reset translation loading for new fetch

    let apiUrl = '';
    const baseUrl = 'https://api.spoonacular.com/recipes/';
    // addRecipeInformation and fillIngredients are useful for getting full details directly
    const commonParams = `number=15&apiKey=${SPOONACULAR_API_KEY}&addRecipeInformation=true&fillIngredients=true`;

    try {
        if (type === 'ingredients') {
            if (userIngredients.length === 0) {
                setLoading(false);
                setApiError(getTranslatedText("pleaseAddIngredient"));
                return;
            }
            const ingredientsString = userIngredients.join(',');
            apiUrl = `${baseUrl}findByIngredients?ingredients=${ingredientsString}&${commonParams}`;
            if (selectedCuisine) {
                apiUrl += `&cuisine=${selectedCuisine}`;
            }
        } else if (type === 'random') { // This is for "View Popular Dishes"
            let queryParams = commonParams;
            if (userIngredients.length > 0 && selectedCuisine) {
                // If ingredients and cuisine are present, prioritize recipes using them within the cuisine, sorted by popularity
                queryParams += `&includeIngredients=${userIngredients.join(',')}`;
                queryParams += `&cuisine=${selectedCuisine}`;
                queryParams += `&sort=popularity`; // Sort by popularity
                apiUrl = `${baseUrl}complexSearch?${queryParams}`;
            } else if (userIngredients.length > 0) {
                // If only ingredients are present, find recipes by ingredients, ranked by matching ingredients
                apiUrl = `${baseUrl}findByIngredients?ingredients=${userIngredients.join(',')}&number=15&ranking=1&apiKey=${SPOONACULAR_API_KEY}`;
            } else if (selectedCuisine) {
                // If only cuisine is selected, get popular recipes for that cuisine
                queryParams += `&cuisine=${selectedCuisine}&sort=popularity`;
                apiUrl = `${baseUrl}complexSearch?${queryParams}`;
            } else {
                // If no ingredients or cuisine, get truly random popular recipes
                apiUrl = `${baseUrl}random?${commonParams}`;
            }
        }

        const response = await fetch(apiUrl);

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        let recipesToProcess = [];
        // Handle different API response structures: /random returns { recipes: [...] }, complexSearch and findByIngredients return [...]
        if (apiUrl.includes('random') && data.recipes) {
            recipesToProcess = data.recipes;
        } else if (Array.isArray(data.results)) { // For complexSearch
            recipesToProcess = data.results;
        } else if (Array.isArray(data)) { // For findByIngredients
            recipesToProcess = data;
        } else {
            console.error("Unexpected data format from Spoonacular API:", data);
            setApiError("Received unexpected data format from recipe API. Please try again.");
            setLoading(false);
            setTranslationLoading(false);
            return;
        }

        const detailedRecipesPromises = recipesToProcess.map(async (recipe) => {
            // Since addRecipeInformation=true is used, often full details are already present.
            // But sometimes, especially for findByIngredients, 'instructions' or 'summary' might still be missing.
            let detailData = recipe;

            // Fetch full details if critical fields are missing or if it's from findByIngredients (which might not always return full info)
            if (!detailData.instructions || !detailData.summary || !detailData.extendedIngredients) {
                try {
                    const detailResponse = await fetch(
                        `${baseUrl}${recipe.id}/information?includeNutrition=false&apiKey=${SPOONACULAR_API_KEY}`
                    );
                    if (!detailResponse.ok) {
                        const errorDetailData = await detailResponse.json();
                        console.error(`Error fetching details for recipe ${recipe.id}:`, errorDetailData.message || detailResponse.status);
                        return null;
                    }
                    detailData = await detailResponse.json();
                } catch (detailError) {
                    console.error(`Failed to fetch details for recipe ${recipe.id}:`, detailError);
                    return null;
                }
            }

            let procedureSteps = [getTranslatedText("noInstructions")];
            if (detailData.instructions) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(detailData.instructions, 'text/html');

                const listItems = Array.from(doc.querySelectorAll('ol li, ul li'));
                if (listItems.length > 0) {
                    procedureSteps = listItems.map(li => li.textContent.trim()).filter(step => step !== '');
                } else {
                    let rawText = '';
                    const paragraphs = Array.from(doc.querySelectorAll('p, div, span'));
                    if (paragraphs.length > 0) {
                      rawText = paragraphs.map(p => p.textContent.trim()).join('\n').trim();
                    } else {
                      rawText = doc.body.textContent.trim();
                    }


                    rawText = rawText.replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ');

                    if (rawText) {
                      let tempSteps = rawText.split(/(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|\!)\s+|\n\s*\n/).filter(step => step.trim() !== '');
                      if (tempSteps.length > 0) {
                        procedureSteps = tempSteps;
                      } else {
                        procedureSteps = [rawText];
                      }
                    }
                }
            }

            // Filter out "waste items/recipes" - simple heuristic: if procedure is too short or description is too generic
            if (procedureSteps.length < 2 || (detailData.summary && detailData.summary.length < 50)) {
                console.log(`Skipping recipe ${detailData.id} due to short procedure or generic description.`);
                return null;
            }

            // --- LLM Translation for dynamic content ---
            let translatedName = detailData.title;
            let translatedDescription = detailData.summary ? detailData.summary.replace(/<\/?[^>]+(>|$)/g, "").substring(0, 150) + '...' : getTranslatedText('noDescription');
            let translatedIngredients = detailData.extendedIngredients ? detailData.extendedIngredients.map(ing => ing.name.toLowerCase()) : [];
            let translatedProcedure = procedureSteps;

            if (language !== 'en') {
                try {
                    const llmResponse = await translateText({
                        name: detailData.title,
                        description: detailData.summary ? detailData.summary.replace(/<\/?[^>]+(>|$)/g, "").substring(0, 150) + '...' : getTranslatedText('noDescription'),
                        ingredients: detailData.extendedIngredients ? detailData.extendedIngredients.map(ing => ing.name.toLowerCase()) : [],
                        procedure: procedureSteps
                    }, language);

                    if (llmResponse) {
                        translatedName = llmResponse.name || translatedName;
                        translatedDescription = llmResponse.description || translatedDescription;
                        translatedIngredients = llmResponse.ingredients || translatedIngredients;
                        translatedProcedure = llmResponse.procedure || translatedProcedure;
                    }
                } catch (llmErr) {
                    console.error("Error during LLM translation for recipe details:", llmErr);
                    // Fallback to English if translation fails
                }
            }
            // --- End LLM Translation ---

            return {
                id: String(detailData.id),
                name: translatedName,
                image: detailData.image,
                ingredients: translatedIngredients,
                description: translatedDescription,
                procedure: translatedProcedure,
                isTranslated: language !== 'en' // Mark if it has been translated
            };
        });

        const detailedRecipes = (await Promise.all(detailedRecipesPromises)).filter(Boolean); // Filter out nulls

        setRecommendedRecipes(detailedRecipes);
        setCurrentScreen(SCREENS.RECIPE_LIST);
    } catch (error) {
        console.error("Error fetching recipes:", error);
        setApiError(`${getTranslatedText("failedToFetchRecipes")} ${error.message}.`);
    } finally {
        setLoading(false);
        setTranslationLoading(false);
    }
  };

  const viewRecipeDetails = async (recipe) => {
    // If the recipe is not yet translated to the current language, translate it now.
    // This typically happens if it's a pre-defined dish that wasn't translated on list render.
    if (language !== 'en' && !recipe.isTranslated && !translationLoading) {
      setTranslationLoading(true);
      try {
        const llmResponse = await translateText({
          name: recipe.name,
          description: recipe.description,
          ingredients: recipe.ingredients,
          procedure: recipe.procedure
        }, language);

        if (llmResponse) {
          setSelectedRecipe({
            ...recipe,
            name: llmResponse.name || recipe.name,
            description: llmResponse.description || recipe.description,
            ingredients: llmResponse.ingredients || recipe.ingredients,
            procedure: llmResponse.procedure || recipe.procedure,
            isTranslated: true // Mark as translated
          });
        } else {
          setSelectedRecipe(recipe); // Fallback to original
        }
      } catch (llmErr) {
        console.error("Error during LLM translation for recipe details:", llmErr);
        setSelectedRecipe(recipe); // Fallback to original
      } finally {
        setTranslationLoading(false);
      }
    } else {
      setSelectedRecipe(recipe);
    }
    setCurrentScreen(SCREENS.RECIPE_DETAIL);
  };

  const startProcedure = () => {
    setCurrentProcedureStep(0);
    setCurrentScreen(SCREENS.PROCEDURE);
    setStepOpacity(0);
    setTimeout(() => setStepOpacity(1), 100);
  };

  const nextStep = () => {
    if (selectedRecipe && selectedRecipe.procedure) { // Added check for selectedRecipe.procedure
      if (currentProcedureStep < selectedRecipe.procedure.length - 1) {
        setStepOpacity(0);
        setTimeout(() => {
          setCurrentProcedureStep(prev => prev + 1);
          setStepOpacity(1);
        }, 300);
      } else {
        setCurrentScreen(SCREENS.COMPLETED);
      }
    }
  };

  const prevStep = () => {
    if (selectedRecipe && selectedRecipe.procedure) { // Added check for selectedRecipe.procedure
      if (currentProcedureStep > 0) {
        setStepOpacity(0);
        setTimeout(() => {
          setCurrentProcedureStep(prev => prev - 1);
          setStepOpacity(1);
        }, 300);
      }
    }
  };

  const copyRecipeToClipboard = () => {
    if (selectedRecipe) {
      const recipeText = `${getTranslatedText("recipe")}: ${selectedRecipe.name}\n\n` +
                         `${getTranslatedText("description")}: ${selectedRecipe.description}\n\n` +
                         `${getTranslatedText("ingredients")}:\n${Array.isArray(selectedRecipe.ingredients) ? selectedRecipe.ingredients.map(ing => `- ${ing}`).join('\n') : ''}\n\n` +
                         `${getTranslatedText("cookingProcedure")}:\n${Array.isArray(selectedRecipe.procedure) ? selectedRecipe.procedure.map((step, index) => `${index + 1}. ${step}`).join('\n') : ''}\n\n` +
                         `Find more delicious recipes on our app!`;

      const textarea = document.createElement('textarea');
      textarea.value = recipeText;
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        setShowCopiedMessage(true);
        setTimeout(() => setShowCopiedMessage(false), 2000);
      } catch (err) {
        console.error('Failed to copy text: ', err);
      } finally {
        document.body.removeChild(textarea);
      }
    }
  };

  // MessageBox Component
  const MessageBox = ({ message, type, onClose }) => {
    if (!message) return null;
    const bgColor = type === 'error' ? 'bg-red-100' : 'bg-green-100';
    const textColor = type === 'error' ? 'text-red-700' : 'text-green-700';
    const borderColor = type === 'error' ? 'border-red-400' : 'border-green-400';

    return (
      <div className={`${bgColor} bg-opacity-80 border ${borderColor} ${textColor} px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70`} role="alert">
        <span className="block sm:inline">{message}</span>
        {onClose && (
          <span className="absolute top-0 bottom-0 right-0 px-4 py-3 cursor-pointer" onClick={onClose}>
            <svg className="fill-current h-6 w-6" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.103l-2.651 3.746a1.2 1.2 0 0 1-1.697-1.697l3.746-2.651-3.746-2.651a1.2 1.2 0 0 1 1.697-1.697L10 8.897l2.651-3.746a1.2 1.2 0 0 1 1.697 1.697L11.103 10l3.746 2.651a1.2 1.2 0 0 1 0 1.698z"/></svg>
          </span>
        )}
      </div>
    );
  };

  // Modal Component for LLM features
  const Modal = ({ title, children, onClose, isLoading }) => {
    if (!children && !isLoading) return null; // Only render if there's content or loading

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 animate-fadeIn">
        <div className="bg-white bg-opacity-90 backdrop-blur-md rounded-xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-70 w-full max-w-md relative">
          <h2 className="text-3xl font-bold text-gray-800 mb-4 text-center">{title}</h2>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center py-8">
              <div className="animate-spin rounded-full h-12 w-12 border-b-4 border-blue-500 mb-4"></div>
              <p className="text-lg text-gray-700">
                {title.includes(getTranslatedText("ingredientSubstitutions")) ? getTranslatedText("findingSubstitutions") : getTranslatedText("generatingIdea")}
              </p>
            </div>
          ) : (
            children
          )}
          <button
            className="absolute top-3 right-3 text-gray-600 hover:text-gray-900"
            onClick={onClose}
          >
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
    );
  };


  // --- UI Rendering based on currentScreen state ---

  // Login Screen
  const renderLoginScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("welcomeBack")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="email-input" className="sr-only">{getTranslatedText("email")}</label>
        <input
          id="email-input"
          type="email"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("email")}
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <label htmlFor="password-input" className="sr-only">{getTranslatedText("password")}</label>
        <input
          id="password-input"
          type="password"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-6 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("password")}
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          onKeyPress={(e) => { if (e.key === 'Enter') handleLogin(); }}
        />
        {authError && (
          <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
            <strong className="font-bold">{getTranslatedText("error")}</strong>
            <span className="block sm:inline"> {authError}</span>
          </div>
        )}
        <button
          className={`w-full bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-blue-400 border-opacity-70 mb-4 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleLogin}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("loginWithEmail")}</span>
          )}
        </button>
        <button
          className={`w-full bg-gradient-to-r from-red-600 to-orange-700 hover:from-red-700 hover:to-orange-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-red-400 border-opacity-70 mb-4 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleGoogleLogin}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("loginWithGoogle")}</span>
          )}
        </button>
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          {getTranslatedText("dontHaveAccount")}{' '}
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.SIGNUP)}
          >
            {getTranslatedText("signUp")}
          </button>
        </p>
        <p className="mt-4 text-center text-gray-700 text-base sm:text-lg">
          Or{' '}
          <button
            className="text-purple-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.PHONE_LOGIN)}
          >
            {getTranslatedText("loginWithPhone")}
          </button>
        </p>
      </div>
    </div>
  );

  // Signup Screen
  const renderSignupScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("createAccount")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="signup-email-input" className="sr-only">{getTranslatedText("email")}</label>
        <input
          id="signup-email-input"
          type="email"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("email")}
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <label htmlFor="signup-password-input" className="sr-only">{getTranslatedText("password")}</label>
        <input
          id="signup-password-input"
          type="password"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-6 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={`${getTranslatedText("password")} (min 6 characters)`}
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          onKeyPress={(e) => { if (e.key === 'Enter') handleSignup(); }}
        />
        {authError && (
          <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
            <strong className="font-bold">{getTranslatedText("error")}</strong>
            <span className="block sm:inline"> {authError}</span>
          </div>
        )}
        <button
          className={`w-full bg-gradient-to-r from-green-600 to-emerald-700 hover:from-green-700 hover:to-emerald-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-green-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleSignup}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("signUp")} with Email</span>
          )}
        </button>
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          {getTranslatedText("alreadyHaveAccount")}{' '}
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.LOGIN)}
          >
            {getTranslatedText("loginWithEmail")}
          </button>
        </p>
      </div>
    </div>
  );

  // Phone Login Screen
  const renderPhoneLoginScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("loginWithPhone")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        {!confirmationResult ? (
          <>
            <label htmlFor="phone-number-input" className="sr-only">{getTranslatedText("enterPhoneNumber")}</label>
            <input
              id="phone-number-input"
              type="tel"
              className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
              placeholder={getTranslatedText("enterPhoneNumber")}
              value={phoneNumber}
              onChange={(e) => setPhoneNumber(e.target.value)}
            />
            {authError && (
              <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
                <strong className="font-bold">{getTranslatedText("error")}</strong>
                <span className="block sm:inline"> {authError}</span>
              </div>
            )}
            <button
              className={`w-full bg-gradient-to-r from-purple-600 to-pink-700 hover:from-purple-700 hover:to-pink-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={handleSendOtp}
              disabled={authLoading}
            >
              {authLoading ? (
                <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
              ) : (
                <span>{getTranslatedText("sendOtp")}</span>
              )}
            </button>
            <div id="recaptcha-container" ref={recaptchaRef} className="mt-4"></div>
            <MessageBox message={showOtpSentMessage ? getTranslatedText("otpSent") : ''} type="success" onClose={() => setShowOtpSentMessage(false)} />
          </>
        ) : (
          <>
            <label htmlFor="verification-code-input" className="sr-only">{getTranslatedText("enterVerificationCode")}</label>
            <input
              id="verification-code-input"
              type="text"
              className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
              placeholder={getTranslatedText("enterVerificationCode")}
              value={verificationCode}
              onChange={(e) => setVerificationCode(e.target.value)}
              onKeyPress={(e) => { if (e.key === 'Enter') handleVerifyOtp(); }}
            />
            {authError && (
              <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
                <strong className="font-bold">{getTranslatedText("error")}</strong>
                <span className="block sm:inline"> {authError}</span>
              </div>
            )}
            <button
              className={`w-full bg-gradient-to-r from-purple-600 to-pink-700 hover:from-purple-700 hover:to-pink-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={handleVerifyOtp}
              disabled={authLoading}
            >
              {authLoading ? (
                <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
              ) : (
                <span>{getTranslatedText("verifyOtp")}</span>
              )}
            </button>
          </>
        )}
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => {
                setCurrentScreen(SCREENS.LOGIN);
                setAuthError(null);
                setConfirmationResult(null);
                setPhoneNumber('');
                setVerificationCode('');
                if (recaptchaVerifier && recaptchaVerifier.reset) {
                  recaptchaVerifier.reset();
                }
            }}
          >
            {getTranslatedText("backToEmailLogin")}
          </button>
        </p>
      </div>
    </div>
  );


  // Home Screen
  const renderHomeScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="absolute top-4 right-4 flex space-x-2">
        <button
          className="bg-gray-700 hover:bg-gray-800 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => setCurrentScreen(SCREENS.SETTINGS)}
        >
          {getTranslatedText("settings")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-6 sm:mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("whatsInKitchen")}</h1>
      <label htmlFor="ingredient-input" className="sr-only">{getTranslatedText("enterIngredient")}</label>
      <input
        id="ingredient-input"
        type="text"
        className="w-full max-w-md p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
        placeholder={getTranslatedText("enterIngredient")}
        value={ingredientsInput}
        onChange={(e) => setIngredientsInput(e.target.value)}
        onKeyPress={(e) => { if (e.key === 'Enter') handleAddIngredient(); }}
      />
      <button
        className="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 mb-6 text-lg sm:text-xl font-semibold border-2 border-green-400 border-opacity-70"
        onClick={handleAddIngredient}
      >
        {getTranslatedText("addIngredient")}
      </button>

      <div className="w-full max-w-lg mt-6 p-5 bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl border-2 border-blue-300 min-h-28 flex flex-col items-center justify-center shadow-2xl border-opacity-60">
        {userIngredients.length > 0 ? (
          <>
            <h2 className="text-xl sm:text-2xl font-bold mt-2 mb-4 text-gray-800">{getTranslatedText("yourIngredients")}</h2>
            <div className="flex flex-wrap justify-center gap-2 mt-2">
              {userIngredients.map((ingredient, index) => (
                <div key={index} className="flex items-center bg-cyan-600 bg-opacity-70 rounded-full py-2 px-4 shadow-md transition-all duration-200 transform hover:scale-105 border border-cyan-400 border-opacity-70 animate-bounce-in">
                  <span className="text-white text-base font-medium mr-2">{ingredient}</span>
                  <button className="text-white font-bold text-base leading-none ml-1 opacity-80 hover:opacity-100" onClick={() => handleRemoveIngredient(ingredient)}>
                    X
                  </button>
                </div>
              ))}
            </div>
            <button
              className="mt-6 bg-red-500 hover:bg-red-600 text-white py-2 px-5 rounded-lg shadow-md transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95"
              onClick={handleClearAllIngredients}
            >
              {getTranslatedText("clearAll")}
            </button>
          </>
        ) : (
          <p className="text-lg text-gray-700 text-center">{getTranslatedText("addSomeIngredients")}</p>
        )}
      </div>

      <div className="w-full max-w-md mt-6">
        <label htmlFor="cuisine-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("selectCuisine")}</label>
        <select
          id="cuisine-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60"
          value={selectedCuisine}
          onChange={(e) => setSelectedCuisine(e.target.value)}
        >
          <option value="">{getTranslatedText("anyCuisine")}</option>
          <option value="Indian">Indian</option>
          <option value="Italian">Italian</option>
          <option value="Mexican">Mexican</option>
          <option value="Chinese">Chinese</option>
          <option value="American">American</option>
          <option value="French">French</option>
          <option value="Japanese">Japanese</option>
          <option value="Mediterranean">Mediterranean</option>
          <option value="Thai">Thai</option>
        </select>
      </div>

      {apiError && (
        <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-6 w-full max-w-lg text-center shadow-lg border-opacity-70" role="alert">
          <strong className="font-bold">{getTranslatedText("error")}</strong>
          <span className="block sm:inline"> {apiError}</span>
        </div>
      )}

      <button
        className={`mt-8 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white py-3 px-10 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-blue-400 border-opacity-70 ${userIngredients.length === 0 || loading || translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={() => fetchRecipes('ingredients')}
        disabled={userIngredients.length === 0 || loading || translationLoading || llmLoading}
      >
        {loading && !translationLoading ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>{getTranslatedText("findRecipes")}</span>
        )}
      </button>

      <button
        className={`mt-4 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-teal-400 border-opacity-70 ${loading || translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={() => fetchRecipes('random')}
        disabled={loading || translationLoading || llmLoading}
      >
        {loading && !translationLoading ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>{getTranslatedText("viewPopularDishes")}</span>
        )}
      </button>

      <button
        className={`mt-4 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${userIngredients.length === 0 || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={handleGenerateCreativeRecipeIdea}
        disabled={userIngredients.length === 0 || llmLoading}
      >
        {llmLoading && showCreativeRecipeModal ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>тЬи {getTranslatedText("generateCreativeIdea")} тЬи</span>
        )}
      </button>

      {showCreativeRecipeModal && (
        <Modal
          title={getTranslatedText("creativeRecipeIdea")}
          onClose={() => setShowCreativeRecipeModal(false)}
          isLoading={llmLoading}
        >
          {creativeRecipeIdea ? (
            <div className="text-left">
              <h3 className="font-bold text-2xl text-gray-800 mb-2">{getTranslatedText("recipeName")}: {creativeRecipeIdea.name}</h3>
              <p className="text-gray-700 text-lg mb-4">{creativeRecipeIdea.description}</p>
              <h4 className="font-semibold text-xl text-gray-800 mb-2">{getTranslatedText("keyIngredients")}:</h4>
              <ul className="list-disc list-inside text-gray-700 text-lg mb-4">
                {creativeRecipeIdea.keyIngredients && creativeRecipeIdea.keyIngredients.map((ing, idx) => (
                  <li key={idx}>{ing}</li>
                ))}
              </ul>
              <h4 className="font-semibold text-xl text-gray-800 mb-2">{getTranslatedText("shortProcedure")}:</h4>
              <ol className="list-decimal list-inside text-gray-700 text-lg">
                {creativeRecipeIdea.shortProcedure && creativeRecipeIdea.shortProcedure.map((step, idx) => (
                  <li key={idx}>{step}</li>
                ))}
              </ol>
            </div>
          ) : (
            <p className="text-gray-700 text-lg">{getTranslatedText("noIdeaGenerated")}</p>
          )}
        </Modal>
      )}
    </div>
  );

  // Recipe List Screen
  const renderRecipeListScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-4xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.HOME); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          &larr; {getTranslatedText("backToIngredients")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-gray-800 text-center drop-shadow-lg">{getTranslatedText("recommendedRecipes")}</h1>

      {loading || translationLoading ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl">
          <RecipeCardSkeleton /><RecipeCardSkeleton /><RecipeCardSkeleton />
          <RecipeCardSkeleton /><RecipeCardSkeleton /><RecipeCardSkeleton />
        </div>
      ) : apiError ? (
        <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-6 w-full max-w-lg text-center shadow-lg border-opacity-70" role="alert">
          <strong className="font-bold">{getTranslatedText("error")}</strong>
          <span className="block sm:inline"> {apiError}</span>
        </div>
      ) : recommendedRecipes.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl">
          {recommendedRecipes.map(recipe => (
            <div
              key={recipe.id}
              className="bg-white bg-opacity-40 backdrop-blur-lg rounded-xl overflow-hidden cursor-pointer transform hover:scale-105 transition-all duration-300 shadow-xl border-2 border-gray-200 border-opacity-60 animate-bounce-in"
              onClick={() => viewRecipeDetails(recipe)}
            >
              <img src={recipe.image} alt={recipe.name} className="w-full h-56 object-cover" />
              <div className="p-5">
                <h3 className="font-bold text-2xl text-gray-800 mb-2">{recipe.name}</h3>
                <p className="text-gray-700 text-lg mb-3">{recipe.description}</p>
                <p className="text-gray-600 text-md">
                  <span className="font-semibold">{getTranslatedText("ingredients")}:</span> {Array.isArray(recipe.ingredients) ? recipe.ingredients.slice(0, 5).join(', ') : ''}{Array.isArray(recipe.ingredients) && recipe.ingredients.length > 5 ? '...' : ''}
                </p>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <p className="text-xl text-gray-700 text-center">{getTranslatedText("noRecipesFound")}</p>
      )}
    </div>
  );

  // Recipe Detail Screen
  const renderRecipeDetailScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-purple-200 via-pink-200 to-orange-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-3xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.RECIPE_LIST); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          &larr; {getTranslatedText("backToRecipes")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      {selectedRecipe && (
        <div className="bg-white bg-opacity-60 backdrop-blur-lg rounded-2xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-3xl">
          <h1 className="font-extrabold text-4xl sm:text-5xl text-center text-gray-800 mb-6 drop-shadow-lg">{selectedRecipe.name}</h1>
          <img src={selectedRecipe.image} alt={selectedRecipe.name} className="w-full h-80 object-cover rounded-xl mb-6 shadow-lg" />

          <h2 className="font-bold text-3xl text-gray-800 mb-4">{getTranslatedText("description")}</h2>
          <p className="text-gray-700 text-lg leading-relaxed mb-6">{selectedRecipe.description}</p>

          <h2 className="font-bold text-3xl text-gray-800 mb-4">{getTranslatedText("ingredients")}</h2>
          <ul className="list-disc list-inside text-gray-700 text-lg mb-8 space-y-2">
            {selectedRecipe?.ingredients?.map((ingredient, index) => ( // Added optional chaining
              <li key={index} className="flex justify-between items-center">
                <span>{ingredient}</span>
                <button
                  className={`ml-2 bg-blue-500 hover:bg-blue-600 text-white text-xs px-3 py-1 rounded-full shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95 ${llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
                  onClick={() => handleIngredientSubstitution(ingredient)}
                  disabled={llmLoading}
                >
                  тЬи {getTranslatedText("substitute")}
                </button>
              </li>
            ))}
          </ul>

          <div className="flex justify-center gap-4 mb-6">
            <button
              className={`bg-orange-500 hover:bg-orange-600 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-orange-400 border-opacity-70 ${translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={startProcedure}
              disabled={translationLoading || llmLoading}
            >
              {getTranslatedText("startCookingProcedure")}
            </button>
            <button
              className="bg-cyan-600 hover:bg-cyan-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-cyan-400 border-opacity-70 relative"
              onClick={copyRecipeToClipboard}
            >
              {getTranslatedText("copyRecipe")}
              {showCopiedMessage && (
                <span className="absolute -top-8 left-1/2 -translate-x-1/2 bg-gray-800 text-white text-sm px-2 py-1 rounded-md animate-fadeIn whitespace-nowrap">{getTranslatedText("copied")}</span>
              )}
            </button>
          </div>
          {translationLoading && (
            <div className="text-center text-blue-700 font-semibold mt-4">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500 inline-block mr-2"></div>
              {getTranslatedText("translatingContent")}...
            </div>
          )}
        </div>
      )}

      {showSubstitutionModal && (
        <Modal
          title={`${getTranslatedText("ingredientSubstitutions")} ${substitutingIngredient}`}
          onClose={() => setShowSubstitutionModal(false)}
          isLoading={llmLoading}
        >
          {substitutionResult && substitutionResult.length > 0 ? (
            <ul className="list-disc list-inside text-gray-700 text-lg space-y-2">
              {substitutionResult.map((sub, idx) => (
                <li key={idx}>
                  <span className="font-semibold">{sub.name}:</span> {sub.note}
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-gray-700 text-lg">{getTranslatedText("noSuggestionsFound")}</p>
          )}
        </Modal>
      )}
    </div>
  );

  // Procedure Screen
  const renderProcedureScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-green-200 via-teal-200 to-blue-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-3xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.RECIPE_DETAIL); setCurrentProcedureStep(0); }} // Reset step on back
        >
          &larr; {getTranslatedText("backToDetails")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      {selectedRecipe && (
        <div className="bg-white bg-opacity-60 backdrop-blur-lg rounded-2xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-3xl">
          <h1 className="font-extrabold text-4xl sm:text-5xl text-center text-gray-800 mb-6 drop-shadow-lg">{getTranslatedText("cookingProcedure")}</h1>

          <div className="relative w-full h-64 sm:h-80 mb-6 bg-gray-100 rounded-xl flex items-center justify-center overflow-hidden shadow-inner">
            <CookingAnimation step={currentProcedureStep} />
            <div className="absolute top-4 right-4 bg-purple-500 text-white text-sm font-bold px-3 py-1 rounded-full shadow-md">
                {getTranslatedText("step")} {currentProcedureStep + 1} / {selectedRecipe?.procedure?.length || 0} {/* Added optional chaining */}
            </div>
          </div>

          <p
            className="text-gray-800 text-xl leading-relaxed mb-8 text-center px-4 sm:px-0 transition-opacity duration-300"
            style={{ opacity: stepOpacity }}
          >
            {selectedRecipe.procedure[currentProcedureStep]}
          </p>

          <div className="flex justify-between gap-4 mt-4">
            <button
              className={`bg-blue-600 hover:bg-blue-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-blue-400 border-opacity-70 ${currentProcedureStep === 0 ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={prevStep}
              disabled={currentProcedureStep === 0}
            >
              &larr; {getTranslatedText("previousStep")}
            </button>
            <button
              className="bg-green-600 hover:bg-green-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-green-400 border-opacity-70"
              onClick={nextStep}
            >
              {currentProcedureStep < (selectedRecipe?.procedure?.length || 0) - 1 ? `${getTranslatedText("nextStep")} \u2192` : getTranslatedText("finishCooking")} {/* Added optional chaining */}
            </button>
          </div>
        </div>
      )}
    </div>
  );

  // Completed Screen
  const renderCompletedScreen = () => (
    <div className="relative flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-pink-200 via-orange-200 to-yellow-200 font-inter text-gray-900 overflow-hidden">
      <div ref={confettiContainerRef} className="absolute inset-0 pointer-events-none z- confettibox"></div> {/* Confetti container */}
      <div className="bg-white bg-opacity-70 backdrop-blur-lg rounded-2xl p-8 sm:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 text-center w-full max-w-xl animate-bounce-in">
        <h1 className="font-extrabold text-5xl sm:text-6xl text-gray-800 mb-6 drop-shadow-lg">{getTranslatedText("congratulations")}</h1>
        <p className="text-xl sm:text-2xl text-gray-700 mb-8">{getTranslatedText("recipeCompleted")} <br /><span className="font-bold text-purple-700">{selectedRecipe?.name || getTranslatedText("yourDish")}</span></p>

        <button
          className="bg-indigo-600 hover:bg-indigo-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-indigo-400 border-opacity-70 mb-4"
          onClick={() => { setCurrentScreen(SCREENS.HOME); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          {getTranslatedText("cookAnotherRecipe")}
        </button>
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-5 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold mt-2"
          onClick={handleLogout}
          disabled={authLoading}
        >
          {getTranslatedText("logout")}
        </button>
      </div>
    </div>
  );

  // Settings Screen
  const renderSettingsScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="absolute top-4 left-4">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => setCurrentScreen(SCREENS.HOME)}
        >
          &larr; {getTranslatedText("backToHome")}
        </button>
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("settings")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="language-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("language")}:</label>
        <select
          id="language-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60 mb-6"
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
        >
          <option value="en">English</option>
          <option value="hi">рд╣рд┐рдВрджреА (Hindi)</option>
          <option value="kn">р▓Хр▓ир│Нр▓ир▓б (Kannada)</option>
          <option value="ta">родрооро┐ро┤рпН (Tamil)</option>
          <option value="ml">р┤ор┤▓р┤пр┤╛р┤│р┤В (Malayalam)</option>
          <option value="te">р░др▒Жр░▓р▒Бр░Чр▒Б (Telugu)</option>
        </select>

        <label htmlFor="default-cuisine-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("defaultCuisine")}:</label>
        <select
          id="default-cuisine-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60"
          value={selectedCuisine}
          onChange={(e) => setSelectedCuisine(e.target.value)} // Update selectedCuisine directly
        >
          <option value="">{getTranslatedText("anyCuisine")}</option>
          <option value="Indian">Indian</option>
          <option value="Italian">Italian</option>
          <option value="Mexican">Mexican</option>
          <option value="Chinese">Chinese</option>
          <option value="American">American</option>
          <option value="French">French</option>
          <option value="Japanese">Japanese</option>
          <option value="Mediterranean">Mediterranean</option>
          <option value="Thai">Thai</option>
        </select>
      </div>
    </div>
  );


  // Render the appropriate screen based on currentScreen state
  const renderScreen = () => {
    if (authLoading) {
      return (
        <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200">
          <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
          <p className="ml-4 text-xl text-gray-700">{getTranslatedText("loadingApp")}</p>
        </div>
      );
    }

    if (!currentUser) {
      switch (currentScreen) {
        case SCREENS.SIGNUP:
          return renderSignupScreen();
        case SCREENS.PHONE_LOGIN:
          return renderPhoneLoginScreen();
        case SCREENS.LOGIN:
        default:
          return renderLoginScreen();
      }
    }

    switch (currentScreen) {
      case SCREENS.HOME:
        return renderHomeScreen();
      case SCREENS.RECIPE_LIST:
        return renderRecipeListScreen();
      case SCREENS.RECIPE_DETAIL:
        return renderRecipeDetailScreen();
      case SCREENS.PROCEDURE:
        return renderProcedureScreen();
      case SCREENS.COMPLETED:
        return renderCompletedScreen();
      case SCREENS.SETTINGS:
        return renderSettingsScreen();
      default:
        return renderHomeScreen();
    }
  };

  return (
    <>
      <style>{customAnimationsCss}</style>
      {renderScreen()}
    </>
  );
};

export default App;
