import React, { useState, useEffect, useRef, useCallback } from 'react';

// Firebase Imports
import { initializeApp } from 'firebase/app';
import {
  getAuth,
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  signInWithPhoneNumber,
  RecaptchaVerifier,
  GoogleAuthProvider, // Import GoogleAuthProvider
  signInWithPopup,
  signInWithCustomToken, // Import signInWithCustomToken
  signInAnonymously // Import signInAnonymously
} from 'firebase/auth';
import {
  getFirestore,
  doc,
  setDoc,
  getDoc,
  updateDoc,
  arrayUnion,
  arrayRemove
} from 'firebase/firestore';

// YOUR SPOONACULAR API KEY
// IMPORTANT: For production deployment, consider moving this API key to a server-side proxy
// or environment variables to prevent client-side exposure.
const SPOONACULAR_API_KEY = '96d9cb981707407ebcf670ed5134907a';

// Gemini API Key (left empty as per instructions for Canvas runtime injection)
const GEMINI_API_KEY = ""; // Canvas will provide this at runtime

// Screen names for navigation
const SCREENS = {
  LOGIN: 'login',
  SIGNUP: 'signup',
  PHONE_LOGIN: 'phone_login',
  HOME: 'home',
  RECIPE_LIST: 'recipe_list',
  RECIPE_DETAIL: 'recipe_detail',
  PROCEDURE: 'procedure',
  COMPLETED: 'completed',
  SETTINGS: 'settings', // New settings screen
};

// Translations for static UI text
const translations = {
  en: {
    welcomeBack: "Welcome Back!",
    createAccount: "Create Account",
    loginWithPhone: "Login with Phone",
    loginWithGoogle: "Login with Google", // New translation key
    email: "Email",
    password: "Password",
    loginWithEmail: "Login with Email",
    dontHaveAccount: "Don't have an account?",
    signUp: "Sign Up",
    alreadyHaveAccount: "Already have an account?",
    backToEmailLogin: "Back to Email Login",
    enterPhoneNumber: "Enter phone number (e.g., +1234567890)",
    sendOtp: "Send OTP",
    enterVerificationCode: "Enter verification code", // Used for placeholder
    verifyOtp: "Verify OTP",
    otpSent: "OTP sent to your phone!",
    whatsInKitchen: "What's in your kitchen?",
    enterIngredient: "Enter ingredient (e.g., 'chicken', 'rice')",
    addIngredient: "Add Ingredient",
    yourIngredients: "Your Ingredients:",
    clearAll: "Clear All",
    selectCuisine: "Select Cuisine (Optional):",
    anyCuisine: "Any Cuisine",
    findRecipes: "Find Recipes",
    recommendedRecipes: "Recommended Recipes",
    backToIngredients: "Back to Ingredients",
    ingredients: "Ingredients",
    description: "Description",
    startCookingProcedure: "Start Cooking Procedure",
    copyRecipe: "Copy Recipe",
    copied: "Copied!",
    cookingProcedure: "Cooking Procedure",
    step: "Step",
    previousStep: "Previous Step",
    nextStep: "Next Step",
    finishCooking: "Finish Cooking!",
    congratulations: "üéâ Congratulations! üéâ",
    recipeCompleted: "You've successfully completed the recipe:",
    cookAnotherRecipe: "Cook Another Recipe",
    logout: "Logout",
    loadingApp: "Loading app...",
    error: "Error:",
    pleaseAddIngredient: "Please add at least one ingredient to find recipes.",
    failedToFetchRecipes: "Failed to fetch recipes:",
    noRecipesFound: "No recipes found for your ingredients and cuisine. Try adding more or changing the cuisine!",
    settings: "Settings",
    language: "Language",
    popularDishes: "Popular Dishes",
    viewPopularDishes: "View Popular Dishes",
    backToHome: "Back to Home",
    noInstructions: "No detailed instructions available for this recipe.",
    failedToLoadUserData: "Failed to load user data. Please try again.",
    failedToSaveIngredient: "Failed to save ingredient to the cloud. Please try again.",
    failedToRemoveIngredient: "Failed to remove ingredient from the cloud. Please try again.",
    failedToClearIngredients: "Failed to clear ingredients in the cloud. Please try again.",
    securityCheckNotReady: "Security check not ready. Please try again.",
    firebaseAuthNotInitialized: "Firebase Auth not initialized.",
    pleaseSendOtpFirst: "Please send OTP first.",
    enterVerificationCodeError: "Please enter the verification code.", // Used for error message
    otpExpired: "Recaptcha expired. Please try sending OTP again.",
    failedToLoadSecurity: "Failed to load security check. Please refresh.",
    failedToInitAuth: "Failed to initialize authentication. Please check your Firebase config.",
    translatingContent: "Translating content",
    yourDish: "Your Dish",
    addSomeIngredients: "Add some ingredients to get started!",
    noDescription: "No description available.",
    recipe: "Recipe",
    backToRecipes: "Back to Recipes",
    defaultCuisine: "Default Cuisine", // New translation key
    backToDetails: "Back to Details", // New translation for procedure screen
    substitute: "Substitute", // New translation key
    ingredientSubstitutions: "Ingredient Substitutions for", // New translation key
    creativeRecipeIdea: "Creative Recipe Idea", // New translation key
    generateCreativeIdea: "Generate Creative Idea", // New translation key
    recipeName: "Recipe Name", // New translation key
    keyIngredients: "Key Ingredients", // New translation key
    close: "Close", // New translation key
    generatingIdea: "Generating idea...", // New translation key
    findingSubstitutions: "Finding substitutions...", // New translation key
    shortProcedure: "Short Procedure", // New translation key
    noIdeaGenerated: "No idea generated.", // New translation key
    noSuggestionsFound: "No suggestions found.", // New translation key
  },
  hi: { // Hindi
    welcomeBack: "‡§µ‡§æ‡§™‡§∏ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à!",
    createAccount: "‡§ñ‡§æ‡§§‡§æ ‡§¨‡§®‡§æ‡§è‡§Ç",
    loginWithPhone: "‡§´‡•ã‡§® ‡§∏‡•á ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡§∞‡•á‡§Ç",
    loginWithGoogle: "‡§ó‡•Ç‡§ó‡§≤ ‡§∏‡•á ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡§∞‡•á‡§Ç", // New translation key
    email: "‡§à‡§Æ‡•á‡§≤",
    password: "‡§™‡§æ‡§∏‡§µ‡§∞‡•ç‡§°",
    loginWithEmail: "‡§à‡§Æ‡•á‡§≤ ‡§∏‡•á ‡§≤‡•â‡§ó‡§ø‡§® ‡§ï‡§∞‡•á‡§Ç",
    dontHaveAccount: "‡§ñ‡§æ‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à?",
    signUp: "‡§∏‡§æ‡§á‡§® ‡§Ö‡§™ ‡§ï‡§∞‡•á‡§Ç",
    alreadyHaveAccount: "‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ñ‡§æ‡§§‡§æ ‡§π‡•à?",
    backToEmailLogin: "‡§à‡§Æ‡•á‡§≤ ‡§≤‡•â‡§ó‡§ø‡§® ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏",
    enterPhoneNumber: "‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç (‡§â‡§¶‡§æ‡§π‡§∞‡§£: +919876543210)",
    sendOtp: "‡§ì‡§ü‡•Ä‡§™‡•Ä ‡§≠‡•á‡§ú‡•á‡§Ç",
    enterVerificationCode: "‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§® ‡§ï‡•ã‡§° ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç", // Used for placeholder
    verifyOtp: "‡§ì‡§ü‡•Ä‡§™‡•Ä ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç",
    otpSent: "‡§Ü‡§™‡§ï‡•á ‡§´‡•ã‡§® ‡§™‡§∞ ‡§ì‡§ü‡•Ä‡§™‡•Ä ‡§≠‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à!",
    whatsInKitchen: "‡§Ü‡§™‡§ï‡•á ‡§∞‡§∏‡•ã‡§à ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?",
    enterIngredient: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç (‡§â‡§¶‡§æ‡§π‡§∞‡§£: '‡§ö‡§ø‡§ï‡§®', '‡§ö‡§æ‡§µ‡§≤')",
    addIngredient: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ú‡•ã‡§°‡§º‡•á‡§Ç",
    yourIngredients: "‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä:",
    clearAll: "‡§∏‡§≠‡•Ä ‡§∏‡§æ‡§´ ‡§ï‡§∞‡•á‡§Ç",
    selectCuisine: "‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§® ‡§ö‡•Å‡§®‡•á‡§Ç (‡§µ‡•à‡§ï‡§≤‡•ç‡§™‡§ø‡§ï):",
    anyCuisine: "‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§®",
    findRecipes: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ñ‡•ã‡§ú‡•á‡§Ç",
    recommendedRecipes: "‡§Ö‡§®‡•Å‡§∂‡§Ç‡§∏‡§ø‡§§ ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§®",
    backToIngredients: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏",
    ingredients: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä",
    description: "‡§µ‡§ø‡§µ‡§∞‡§£",
    startCookingProcedure: "‡§ñ‡§æ‡§®‡§æ ‡§™‡§ï‡§æ‡§®‡•á ‡§ï‡•Ä ‡§µ‡§ø‡§ß‡§ø ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç",
    copyRecipe: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ï‡•â‡§™‡•Ä ‡§ï‡§∞‡•á‡§Ç",
    copied: "‡§ï‡•â‡§™‡•Ä ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!",
    cookingProcedure: "‡§ñ‡§æ‡§®‡§æ ‡§™‡§ï‡§æ‡§®‡•á ‡§ï‡•Ä ‡§µ‡§ø‡§ß‡§ø",
    step: "‡§ö‡§∞‡§£",
    previousStep: "‡§™‡§ø‡§õ‡§≤‡§æ ‡§ö‡§∞‡§£",
    nextStep: "‡§Ö‡§ó‡§≤‡§æ ‡§ö‡§∞‡§£",
    finishCooking: "‡§ñ‡§æ‡§®‡§æ ‡§™‡§ï‡§æ‡§®‡§æ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§ï‡§∞‡•á‡§Ç!",
    congratulations: "üéâ ‡§¨‡§ß‡§æ‡§à ‡§π‡•ã! üéâ",
    recipeCompleted: "‡§Ü‡§™‡§®‡•á ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§™‡•Ç‡§∞‡•Ä ‡§ï‡§∞ ‡§≤‡•Ä ‡§π‡•à:",
    cookAnotherRecipe: "‡§è‡§ï ‡§î‡§∞ ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§¨‡§®‡§æ‡§è‡§Ç",
    logout: "‡§≤‡•â‡§ó ‡§Ü‡§â‡§ü",
    loadingApp: "‡§ê‡§™ ‡§≤‡•ã‡§° ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
    error: "‡§§‡•ç‡§∞‡•Å‡§ü‡§ø:",
    pleaseAddIngredient: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ñ‡•ã‡§ú‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§è‡§ï ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§",
    failedToFetchRecipes: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§≤‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤:",
    noRecipesFound: "‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ã‡§à ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä‡•§ ‡§Ö‡§ß‡§ø‡§ï ‡§ú‡•ã‡§°‡§º‡•á‡§Ç ‡§Ø‡§æ ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§® ‡§¨‡§¶‡§≤‡•á‡§Ç!",
    settings: "‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏",
    language: "‡§≠‡§æ‡§∑‡§æ",
    popularDishes: "‡§≤‡•ã‡§ï‡§™‡•ç‡§∞‡§ø‡§Ø ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§®",
    viewPopularDishes: "‡§≤‡•ã‡§ï‡§™‡•ç‡§∞‡§ø‡§Ø ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§® ‡§¶‡•á‡§ñ‡•á‡§Ç",
    backToHome: "‡§π‡•ã‡§Æ ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏",
    noInstructions: "‡§á‡§∏ ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ã‡§à ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§®‡§ø‡§∞‡•ç‡§¶‡•á‡§∂ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§",
    failedToLoadUserData: "‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§°‡•á‡§ü‡§æ ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    failedToSaveIngredient: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•ã ‡§ï‡•ç‡§≤‡§æ‡§â‡§° ‡§™‡§∞ ‡§∏‡§π‡•á‡§ú‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    failedToRemoveIngredient: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•ã ‡§ï‡•ç‡§≤‡§æ‡§â‡§° ‡§∏‡•á ‡§π‡§ü‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    failedToClearIngredients: "‡§ï‡•ç‡§≤‡§æ‡§â‡§° ‡§Æ‡•á‡§Ç ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    securityCheckNotReady: "‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ ‡§ú‡§æ‡§Ç‡§ö ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    firebaseAuthNotInitialized: "‡§´‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡•Ä‡§ï‡§∞‡§£ ‡§™‡•ç‡§∞‡§æ‡§∞‡§Ç‡§≠ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü‡•§",
    pleaseSendOtpFirst: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§π‡§≤‡•á ‡§ì‡§ü‡•Ä‡§™‡•Ä ‡§≠‡•á‡§ú‡•á‡§Ç‡•§",
    enterVerificationCodeError: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§§‡•ç‡§Ø‡§æ‡§™‡§® ‡§ï‡•ã‡§° ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§", // Used for error message
    otpExpired: "‡§∞‡§ø‡§ï‡•à‡§™‡•ç‡§ö‡§æ ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ì‡§ü‡•Ä‡§™‡•Ä ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§≠‡•á‡§ú‡§®‡•á ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
    failedToLoadSecurity: "‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ ‡§ú‡§æ‡§Ç‡§ö ‡§≤‡•ã‡§° ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∞‡•Ä‡§´‡•ç‡§∞‡•á‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§",
    failedToInitAuth: "‡§™‡•ç‡§∞‡§Æ‡§æ‡§£‡•Ä‡§ï‡§∞‡§£ ‡§™‡•ç‡§∞‡§æ‡§∞‡§Ç‡§≠ ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•Ä ‡§´‡§æ‡§Ø‡§∞‡§¨‡•á‡§∏ ‡§ï‡•â‡§®‡•ç‡§´‡§º‡§ø‡§ó‡§∞‡•á‡§∂‡§® ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç„ÄÇ",
    translatingContent: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à",
    yourDish: "‡§Ü‡§™‡§ï‡§æ ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§®",
    addSomeIngredients: "‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•Å‡§õ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ú‡•ã‡§°‡§º‡•á‡§Ç!",
    noDescription: "‡§á‡§∏ ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•ã‡§à ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§",
    recipe: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä",
    backToRecipes: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏",
    defaultCuisine: "‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§µ‡•ç‡§Ø‡§Ç‡§ú‡§®", // New translation key
    backToDetails: "‡§µ‡§ø‡§µ‡§∞‡§£ ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏", // New translation for procedure screen
    substitute: "‡§¨‡§¶‡§≤‡•á‡§Ç", // New translation key
    ingredientSubstitutions: "‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä ‡§ï‡•á ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™", // New translation key
    creativeRecipeIdea: "‡§∞‡§ö‡§®‡§æ‡§§‡•ç‡§Æ‡§ï ‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§µ‡§ø‡§ö‡§æ‡§∞", // New translation key
    generateCreativeIdea: "‡§∞‡§ö‡§®‡§æ‡§§‡•ç‡§Æ‡§ï ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§ï‡§∞‡•á‡§Ç", // New translation key
    recipeName: "‡§∞‡•á‡§∏‡§ø‡§™‡•Ä ‡§ï‡§æ ‡§®‡§æ‡§Æ", // New translation key
    keyIngredients: "‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä", // New translation key
    close: "‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç", // New translation key
    generatingIdea: "‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...", // New translation key
    findingSubstitutions: "‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§ñ‡•ã‡§ú‡•á ‡§ú‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...", // New translation key
    shortProcedure: "‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§µ‡§ø‡§ß‡§ø", // New translation key
    noIdeaGenerated: "‡§ï‡•ã‡§à ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§â‡§§‡•ç‡§™‡§®‡•ç‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü‡•§", // New translation key
    noSuggestionsFound: "‡§ï‡•ã‡§à ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§", // New translation key
  },
  kn: { // Kannada
    welcomeBack: "‡≤Æ‡≤∞‡≤≥‡≤ø ‡≤∏‡≥ç‡≤µ‡≤æ‡≤ó‡≤§!",
    createAccount: "‡≤ñ‡≤æ‡≤§‡≥Ü ‡≤∞‡≤ö‡≤ø‡≤∏‡≤ø",
    loginWithPhone: "‡≤´‡≥ã‡≤®‡≥ç ‡≤Æ‡≥Ç‡≤≤‡≤ï ‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
    loginWithGoogle: "‡≤ó‡≥Ç‡≤ó‡≤≤‡≥ç ‡≤Æ‡≥Ç‡≤≤‡≤ï ‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø", // New translation key
    email: "‡≤á‡≤Æ‡≥á‡≤≤‡≥ç",
    password: "‡≤™‡≤æ‡≤∏‡≥ç‡≤µ‡≤∞‡≥ç‡≤°‡≥ç",
    loginWithEmail: "‡≤á‡≤Æ‡≥á‡≤≤‡≥ç ‡≤Æ‡≥Ç‡≤≤‡≤ï ‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
    dontHaveAccount: "‡≤ñ‡≤æ‡≤§‡≥Ü ‡≤á‡≤≤‡≥ç‡≤≤‡≤µ‡≥á?",
    signUp: "‡≤∏‡≥à‡≤®‡≥ç ‡≤Ö‡≤™‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø",
    alreadyHaveAccount: "‡≤à‡≤ó‡≤æ‡≤ó‡≤≤‡≥á ‡≤ñ‡≤æ‡≤§‡≥Ü ‡≤á‡≤¶‡≥Ü‡≤Ø‡≥á?",
    backToEmailLogin: "‡≤á‡≤Æ‡≥á‡≤≤‡≥ç ‡≤≤‡≤æ‡≤ó‡≤ø‡≤®‡≥ç‚Äå‡≤ó‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø",
    enterPhoneNumber: "‡≤´‡≥ã‡≤®‡≥ç ‡≤∏‡≤Ç‡≤ñ‡≥ç‡≤Ø‡≥Ü ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø (‡≤â‡≤¶‡≤æ: +919876543210)",
    sendOtp: "OTP ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤ø",
    enterVerificationCode: "‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤®‡≤æ ‡≤ï‡≥ã‡≤°‡≥ç ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø", // Used for placeholder
    verifyOtp: "OTP ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤ø‡≤∏‡≤ø",
    otpSent: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤´‡≥ã‡≤®‡≥ç‚Äå‡≤ó‡≥Ü OTP ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
    whatsInKitchen: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü‡≤Æ‡≤®‡≥Ü‡≤Ø‡≤≤‡≥ç‡≤≤‡≤ø ‡≤è‡≤®‡≤ø‡≤¶‡≥Ü?",
    enterIngredient: "‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤• ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø (‡≤â‡≤¶‡≤æ: '‡≤ö‡≤ø‡≤ï‡≤®‡≥ç', '‡≤Ö‡≤ï‡≥ç‡≤ï‡≤ø')",
    addIngredient: "‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤• ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø",
    yourIngredients: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≥Å:",
    clearAll: "‡≤é‡≤≤‡≥ç‡≤≤‡≤µ‡≤®‡≥ç‡≤®‡≥Ç ‡≤§‡≥Ü‡≤∞‡≤µ‡≥Å‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤ø",
    selectCuisine: "‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤∂‡≥à‡≤≤‡≤ø ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤Æ‡≤æ‡≤°‡≤ø (‡≤ê‡≤ö‡≥ç‡≤õ‡≤ø‡≤ï):",
    anyCuisine: "‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤∂‡≥à‡≤≤‡≤ø",
    findRecipes: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤π‡≥Å‡≤°‡≥Å‡≤ï‡≤ø",
    recommendedRecipes: "‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å ‡≤Æ‡≤æ‡≤°‡≤ø‡≤¶ ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≥Å",
    backToIngredients: "‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≤ø‡≤ó‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø",
    ingredients: "‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≥Å",
    description: "‡≤µ‡≤ø‡≤µ‡≤∞‡≤£‡≥Ü",
    startCookingProcedure: "‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤µ‡≤ø‡≤ß‡≤æ‡≤® ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤ø",
    copyRecipe: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤® ‡≤®‡≤ï‡≤≤‡≤ø‡≤∏‡≤ø",
    copied: "‡≤®‡≤ï‡≤≤‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü!",
    cookingProcedure: "‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤µ‡≤ø‡≤ß‡≤æ‡≤®",
    step: "‡≤π‡≤Ç‡≤§",
    previousStep: "‡≤π‡≤ø‡≤Ç‡≤¶‡≤ø‡≤® ‡≤π‡≤Ç‡≤§",
    nextStep: "‡≤Æ‡≥Å‡≤Ç‡≤¶‡≤ø‡≤® ‡≤π‡≤Ç‡≤§",
    finishCooking: "‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤∏‡≤ø!",
    congratulations: "üéâ ‡≤Ö‡≤≠‡≤ø‡≤®‡≤Ç‡≤¶‡≤®‡≥Ü‡≤ó‡≤≥‡≥Å! üéâ",
    recipeCompleted: "‡≤®‡≥Ä‡≤µ‡≥Å ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ø‡≤∂‡≤∏‡≥ç‡≤µ‡≤ø‡≤Ø‡≤æ‡≤ó‡≤ø ‡≤™‡≥Ç‡≤∞‡≥ç‡≤£‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤ø‡≤¶‡≥ç‡≤¶‡≥Ä‡≤∞‡≤ø:",
    cookAnotherRecipe: "‡≤Æ‡≤§‡≥ç‡≤§‡≥ä‡≤Ç‡≤¶‡≥Å ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤® ‡≤Æ‡≤æ‡≤°‡≤ø",
    logout: "‡≤≤‡≤æ‡≤ó‡≥ç ‡≤î‡≤ü‡≥ç",
    loadingApp: "‡≤Ö‡≤™‡≥ç‡≤≤‡≤ø‡≤ï‡≥á‡≤∂‡≤®‡≥ç ‡≤≤‡≥ã‡≤°‡≥ç ‡≤Ü‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...",
    error: "‡≤¶‡≥ã‡≤∑:",
    pleaseAddIngredient: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤π‡≥Å‡≤°‡≥Å‡≤ï‡≤≤‡≥Å ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤ï‡≤®‡≤ø‡≤∑‡≥ç‡≤† ‡≤í‡≤Ç‡≤¶‡≥Å ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø.",
    failedToFetchRecipes: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü:",
    noRecipesFound: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤∂‡≥à‡≤≤‡≤ø‡≤ó‡≥Ü ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≥Å ‡≤ï‡≤Ç‡≤°‡≥Å‡≤¨‡≤Ç‡≤¶‡≤ø‡≤≤‡≥ç‡≤≤. ‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≤ø‡≤®‡≤¶‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø ‡≤Ö‡≤•‡≤µ‡≤æ ‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤∂‡≥à‡≤≤‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤¨‡≤¶‡≤≤‡≤æ‡≤Ø‡≤ø‡≤∏‡≤ø!",
    settings: "‡≤∏‡≥Ü‡≤ü‡≥ç‡≤ü‡≤ø‡≤Ç‡≤ó‡≥ç‚Äå‡≤ó‡≤≥‡≥Å",
    language: "‡≤≠‡≤æ‡≤∑‡≥Ü",
    popularDishes: "‡≤ú‡≤®‡≤™‡≥ç‡≤∞‡≤ø‡≤Ø ‡≤ñ‡≤æ‡≤¶‡≥ç‡≤Ø‡≤ó‡≤≥‡≥Å",
    viewPopularDishes: "‡≤ú‡≤®‡≤™‡≥ç‡≤∞‡≤ø‡≤Ø ‡≤ñ‡≤æ‡≤¶‡≥ç‡≤Ø‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤µ‡≥Ä‡≤ï‡≥ç‡≤∑‡≤ø‡≤∏‡≤ø",
    backToHome: "‡≤Æ‡≥Å‡≤ñ‡≤™‡≥Å‡≤ü‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø",
    noInstructions: "‡≤à ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤µ‡≤ø‡≤µ‡≤∞‡≤µ‡≤æ‡≤¶ ‡≤∏‡≥Ç‡≤ö‡≤®‡≥Ü‡≤ó‡≤≥‡≥Å ‡≤≤‡≤≠‡≥ç‡≤Ø‡≤µ‡≤ø‡≤≤‡≥ç‡≤≤.",
    failedToLoadUserData: "‡≤¨‡≤≥‡≤ï‡≥Ü‡≤¶‡≤æ‡≤∞ ‡≤°‡≥á‡≤ü‡≤æ‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤≤‡≥ã‡≤°‡≥ç ‡≤Æ‡≤æ‡≤°‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    failedToSaveIngredient: "‡≤ï‡≥ç‡≤≤‡≥å‡≤°‡≥ç‚Äå‡≤ó‡≥Ü ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤â‡≤≥‡≤ø‡≤∏‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    failedToRemoveIngredient: "‡≤ï‡≥ç‡≤≤‡≥å‡≤°‡≥ç‚Äå‡≤®‡≤ø‡≤Ç‡≤¶ ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≥Ü‡≤ó‡≥Ü‡≤¶‡≥Å‡≤π‡≤æ‡≤ï‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    failedToClearIngredients: "‡≤ï‡≥ç‡≤≤‡≥å‡≤°‡≥ç‚Äå‡≤®‡≤≤‡≥ç‡≤≤‡≤ø‡≤∞‡≥Å‡≤µ ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≥Ü‡≤∞‡≤µ‡≥Å‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    securityCheckNotReady: "‡≤≠‡≤¶‡≥ç‡≤∞‡≤§‡≤æ ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤®‡≥Ü ‡≤∏‡≤ø‡≤¶‡≥ç‡≤ß‡≤µ‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    firebaseAuthNotInitialized: "‡≤´‡≥à‡≤∞‡≥ç‚Äå‡≤¨‡≥á‡≤∏‡≥ç ‡≤¶‡≥É‡≤¢‡≥Ä‡≤ï‡≤∞‡≤£ ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤µ‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤.",
    pleaseSendOtpFirst: "‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≥ä‡≤¶‡≤≤‡≥Å OTP ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤ø.",
    enterVerificationCodeError: "‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤®‡≤æ ‡≤ï‡≥ã‡≤°‡≥ç ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø„ÄÇ", // Used for error message
    otpExpired: "‡≤∞‡≥Ä‡≤ï‡≥ç‡≤Ø‡≤æ‡≤™‡≥ç‡≤ö‡≤æ ‡≤Ö‡≤µ‡≤ß‡≤ø ‡≤Æ‡≥Å‡≤ó‡≤ø‡≤¶‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å OTP ‡≤Ö‡≤®‡≥ç‡≤®‡≥Å ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≥Å ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.",
    failedToLoadSecurity: "‡≤≠‡≤¶‡≥ç‡≤∞‡≤§‡≤æ ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤®‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤≤‡≥ã‡≤°‡≥ç ‡≤Æ‡≤æ‡≤°‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤∞‡≤ø‡≤´‡≥ç‡≤∞‡≥Ü‡≤∂‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø.",
    failedToInitAuth: "‡≤¶‡≥É‡≤¢‡≥Ä‡≤ï‡≤∞‡≤£‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤´‡≥à‡≤∞‡≥ç‚Äå‡≤¨‡≥á‡≤∏‡≥ç ‡≤ï‡≤æ‡≤®‡≥ç‡≤´‡≤ø‡≤ó‡≤∞‡≥á‡≤∂‡≤®‡≥ç ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤ø‡≤∏‡≤ø„ÄÇ",
    translatingContent: "‡≤µ‡≤ø‡≤∑‡≤Ø‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ö‡≤®‡≥Å‡≤µ‡≤æ‡≤¶‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü",
    yourDish: "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤ñ‡≤æ‡≤¶‡≥ç‡≤Ø",
    addSomeIngredients: "‡≤™‡≥ç‡≤∞‡≤æ‡≤∞‡≤Ç‡≤≠‡≤ø‡≤∏‡≤≤‡≥Å ‡≤ï‡≥Ü‡≤≤‡≤µ‡≥Å ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤∏‡≥á‡≤∞‡≤ø‡≤∏‡≤ø!",
    noDescription: "‡≤à ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ï‡≥ç‡≤ï‡≥Ü ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤µ‡≤ø‡≤µ‡≤∞‡≤£‡≥Ü ‡≤≤‡≤≠‡≥ç‡≤Ø‡≤µ‡≤ø‡≤≤‡≥ç‡≤≤.",
    recipe: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®",
    backToRecipes: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤ó‡≤≥‡≤ø‡≤ó‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø",
    defaultCuisine: "‡≤°‡≥Ä‡≤´‡≤æ‡≤≤‡≥ç‡≤ü‡≥ç ‡≤Ö‡≤°‡≥Å‡≤ó‡≥Ü ‡≤∂‡≥à‡≤≤‡≤ø", // New translation key
    backToDetails: "‡≤µ‡≤ø‡≤µ‡≤∞‡≤ó‡≤≥‡≤ø‡≤ó‡≥Ü ‡≤π‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤ó‡≤ø", // New translation for procedure screen
    substitute: "‡≤¨‡≤¶‡≤≤‡≤æ‡≤µ‡≤£‡≥Ü", // New translation key
    ingredientSubstitutions: "‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤¶ ‡≤™‡≤∞‡≥ç‡≤Ø‡≤æ‡≤Ø‡≤ó‡≤≥‡≥Å", // New translation key
    creativeRecipeIdea: "‡≤∏‡≥É‡≤ú‡≤®‡≤æ‡≤§‡≥ç‡≤Æ‡≤ï ‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤® ‡≤ï‡≤≤‡≥ç‡≤™‡≤®‡≥Ü", // New translation key
    generateCreativeIdea: "‡≤∏‡≥É‡≤ú‡≤®‡≤æ‡≤§‡≥ç‡≤Æ‡≤ï ‡≤ï‡≤≤‡≥ç‡≤™‡≤®‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤∞‡≤ö‡≤ø‡≤∏‡≤ø", // New translation key
    recipeName: "‡≤™‡≤æ‡≤ï‡≤µ‡≤ø‡≤ß‡≤æ‡≤®‡≤¶ ‡≤π‡≥Ü‡≤∏‡≤∞‡≥Å", // New translation key
    keyIngredients: "‡≤™‡≥ç‡≤∞‡≤Æ‡≥Å‡≤ñ ‡≤™‡≤¶‡≤æ‡≤∞‡≥ç‡≤•‡≤ó‡≤≥‡≥Å", // New translation key
    close: "‡≤Æ‡≥Å‡≤ö‡≥ç‡≤ö‡≤ø", // New translation key
    generatingIdea: "‡≤ï‡≤≤‡≥ç‡≤™‡≤®‡≥Ü ‡≤∞‡≤ö‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...", // New translation key
    findingSubstitutions: "‡≤™‡≤∞‡≥ç‡≤Ø‡≤æ‡≤Ø‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤π‡≥Å‡≤°‡≥Å‡≤ï‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...", // New translation key
    shortProcedure: "‡≤∏‡≤Ç‡≤ï‡≥ç‡≤∑‡≤ø‡≤™‡≥ç‡≤§ ‡≤µ‡≤ø‡≤ß‡≤æ‡≤®", // New translation key
    noIdeaGenerated: "‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤ï‡≤≤‡≥ç‡≤™‡≤®‡≥Ü ‡≤∞‡≤ö‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤.", // New translation key
    noSuggestionsFound: "‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥‡≥Å ‡≤ï‡≤Ç‡≤°‡≥Å‡≤¨‡≤Ç‡≤¶‡≤ø‡≤≤‡≥ç‡≤≤.", // New translation key
  },
  ta: { // Tamil
    welcomeBack: "‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æµ‡Æ∞‡ØÅ‡Æï!",
    createAccount: "‡Æï‡Æ£‡Æï‡Øç‡Æï‡Øà ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ",
    loginWithPhone: "‡Æ§‡Øä‡Æ≤‡Øà‡Æ™‡Øá‡Æö‡Æø ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà‡Æï",
    loginWithGoogle: "‡Æï‡ØÇ‡Æï‡Æø‡Æ≥‡Øç ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà‡Æï", // New translation key
    email: "‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç",
    password: "‡Æï‡Æü‡Æµ‡ØÅ‡Æö‡Øç‡Æö‡Øä‡Æ≤‡Øç",
    loginWithEmail: "‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà",
    dontHaveAccount: "‡Æï‡Æ£‡Æï‡Øç‡Æï‡ØÅ ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà‡ÆØ‡Ææ?",
    signUp: "‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï",
    alreadyHaveAccount: "‡Æè‡Æ±‡Øç‡Æï‡Æ©‡Æµ‡Øá ‡Æï‡Æ£‡Æï‡Øç‡Æï‡ØÅ ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡Ææ?",
    backToEmailLogin: "‡ÆÆ‡Æø‡Æ©‡Øç‡Æ©‡Æû‡Øç‡Æö‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ®‡ØÅ‡Æ¥‡Øà‡Æµ‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ",
    enterPhoneNumber: "‡Æ§‡Øä‡Æ≤‡Øà‡Æ™‡Øá‡Æö‡Æø ‡Æé‡Æ£‡Øç‡Æ£‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æé.‡Æï‡Ææ: +919876543210)",
    sendOtp: "OTP ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡ØÅ",
    enterVerificationCode: "‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Æø‡ÆØ‡ØÄ‡Æü‡Øç‡Æü‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç", // Used for placeholder
    verifyOtp: "OTP ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç",
    otpSent: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Øä‡Æ≤‡Øà‡Æ™‡Øá‡Æö‡Æø‡Æï‡Øç‡Æï‡ØÅ OTP ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!",
    whatsInKitchen: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Æ±‡Øà‡ÆØ‡Æø‡Æ≤‡Øç ‡Æé‡Æ©‡Øç‡Æ© ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ±‡Æ§‡ØÅ?",
    enterIngredient: "‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æé.‡Æï‡Ææ: '‡Æö‡Æø‡Æï‡Øç‡Æï‡Æ©‡Øç', '‡ÆÖ‡Æ∞‡Æø‡Æö‡Æø')",
    addIngredient: "‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç",
    yourIngredients: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç:",
    clearAll: "‡ÆÖ‡Æ©‡Øà‡Æ§‡Øç‡Æ§‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ¥‡Æø",
    selectCuisine: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æµ‡Æï‡Øà‡ÆØ‡Øà‡Æ§‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç (‡Æµ‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡Æø‡Æ©‡Ææ‡Æ≤‡Øç):",
    anyCuisine: "‡Æé‡Æ®‡Øç‡Æ§ ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æµ‡Æï‡Øà",
    findRecipes: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç",
    recommendedRecipes: "‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç",
    backToIngredients: "‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ",
    ingredients: "‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç",
    description: "‡Æµ‡Æø‡Æ≥‡Æï‡Øç‡Æï‡ÆÆ‡Øç",
    startCookingProcedure: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆÆ‡ØÅ‡Æ±‡Øà‡ÆØ‡Øà‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ",
    copyRecipe: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Øà ‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ",
    copied: "‡Æ®‡Æï‡Æ≤‡ØÜ‡Æü‡ØÅ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ!",
    cookingProcedure: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆÆ‡ØÅ‡Æ±‡Øà",
    step: "‡Æ™‡Æü‡Æø",
    previousStep: "‡ÆÆ‡ØÅ‡Æ®‡Øç‡Æ§‡Øà‡ÆØ ‡Æ™‡Æü‡Æø",
    nextStep: "‡ÆÖ‡Æü‡ØÅ‡Æ§‡Øç‡Æ§ ‡Æ™‡Æü‡Æø",
    finishCooking: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øà ‡ÆÆ‡ØÅ‡Æü‡Æø!",
    congratulations: "üéâ ‡Æµ‡Ææ‡Æ¥‡Øç‡Æ§‡Øç‡Æ§‡ØÅ‡Æï‡Øç‡Æï‡Æ≥‡Øç! üéâ",
    recipeCompleted: "‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Øà ‡Æµ‡ØÜ‡Æ±‡Øç‡Æ±‡Æø‡Æï‡Æ∞‡ÆÆ‡Ææ‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡Æ§‡Øç‡Æ§‡ØÅ‡Æµ‡Æø‡Æü‡Øç‡Æü‡ØÄ‡Æ∞‡Øç‡Æï‡Æ≥‡Øç:",
    cookAnotherRecipe: "‡ÆÆ‡Æ±‡Øç‡Æ±‡Øä‡Æ∞‡ØÅ ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡Øà ‡Æö‡ÆÆ‡Øà",
    logout: "‡Æµ‡ØÜ‡Æ≥‡Æø‡ÆØ‡Øá‡Æ±‡ØÅ",
    loadingApp: "‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Ææ‡Æü‡ØÅ ‡Æè‡Æ±‡Øç‡Æ±‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ...",
    error: "‡Æ™‡Æø‡Æ¥‡Øà:",
    pleaseAddIngredient: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡ÆØ ‡Æï‡ØÅ‡Æ±‡Øà‡Æ®‡Øç‡Æ§‡Æ™‡Æü‡Øç‡Æö‡ÆÆ‡Øç ‡Æí‡Æ∞‡ØÅ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToFetchRecipes: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡ØÜ‡Æ± ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà:",
    noRecipesFound: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æµ‡Æï‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç ‡Æé‡Æ§‡ØÅ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡Øá‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æµ‡Æï‡Øà‡ÆØ‡Øà ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æµ‡ØÅ‡ÆÆ‡Øç!",
    settings: "‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç",
    language: "‡ÆÆ‡Øä‡Æ¥‡Æø",
    popularDishes: "‡Æ™‡Æø‡Æ∞‡Æ™‡Æ≤‡ÆÆ‡Ææ‡Æ© ‡Æâ‡Æ£‡Æµ‡ØÅ‡Æï‡Æ≥‡Øç",
    viewPopularDishes: "‡Æ™‡Æø‡Æ∞‡Æ™‡Æ≤‡ÆÆ‡Ææ‡Æ© ‡Æâ‡Æ£‡Æµ‡ØÅ‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Ææ‡Æ£‡Øç‡Æï",
    backToHome: "‡ÆÆ‡ØÅ‡Æï‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ",
    noInstructions: "‡Æá‡Æ®‡Øç‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Æø‡Æ∞‡Æø‡Æµ‡Ææ‡Æ© ‡Æµ‡Æ¥‡Æø‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Æ≥‡Øç ‡Æé‡Æ§‡ØÅ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.",
    failedToLoadUserData: "‡Æ™‡ÆØ‡Æ©‡Æ∞‡Øç ‡Æ§‡Æ∞‡Æµ‡Øà ‡Æè‡Æ±‡Øç‡Æ± ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToSaveIngredient: "‡Æï‡Æø‡Æ≥‡Æµ‡ØÅ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øà ‡Æö‡Øá‡ÆÆ‡Æø‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToRemoveIngredient: "‡Æï‡Æø‡Æ≥‡Æµ‡ØÅ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡ØÅ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æ≥‡Øà ‡ÆÖ‡Æï‡Æ±‡Øç‡Æ± ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToClearIngredients: "‡Æï‡Æø‡Æ≥‡Æµ‡ØÅ‡Æü‡Øç‡Æü‡Æø‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øà ‡ÆÖ‡Æ¥‡Æø‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    securityCheckNotReady: "‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡ØÅ‡Æö‡Øç ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ§‡ÆØ‡Ææ‡Æ∞‡Ææ‡Æï ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    firebaseAuthNotInitialized: "‡ÆÉ‡Æ™‡ÆØ‡Æ∞‡Øç‡Æ™‡Øá‡Æ∏‡Øç ‡ÆÖ‡Æô‡Øç‡Æï‡ØÄ‡Æï‡Ææ‡Æ∞‡ÆÆ‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.",
    pleaseSendOtpFirst: "‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÅ‡Æ§‡Æ≤‡Æø‡Æ≤‡Øç OTP ‡Æê ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    enterVerificationCodeError: "‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡ØÅ ‡Æï‡ØÅ‡Æ±‡Æø‡ÆØ‡ØÄ‡Æü‡Øç‡Æü‡Øà ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æø‡Æü‡Æµ‡ØÅ‡ÆÆ‡Øç„ÄÇ", // Used for error message
    otpExpired: "‡Æ∞‡ØÄ‡Æï‡Øá‡Æ™‡Øç‡Æö‡Ææ ‡Æï‡Ææ‡Æ≤‡Ææ‡Æµ‡Æ§‡Æø‡ÆØ‡Ææ‡Æ©‡Æ§‡ØÅ. ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ OTP ‡Æê ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™ ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToLoadSecurity: "‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡ØÅ‡Æö‡Øç ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æ™‡Øç‡Æ™‡Øà ‡Æè‡Æ±‡Øç‡Æ± ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æ™‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
    failedToInitAuth: "‡ÆÖ‡Æô‡Øç‡Æï‡ØÄ‡Æï‡Ææ‡Æ∞‡Æ§‡Øç‡Æ§‡Øà‡Æ§‡Øç ‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà. ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡ÆÉ‡Æ™‡ÆØ‡Æ∞‡Øç‡Æ™‡Øá‡Æ∏‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡ÆÆ‡Øà‡Æµ‡Øà‡Æö‡Øç ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç„ÄÇ",
    translatingContent: "‡Æâ‡Æ≥‡Øç‡Æ≥‡Æü‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡ÆÆ‡Øä‡Æ¥‡Æø‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ",
    yourDish: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æü‡Æø‡Æ∑‡Øç",
    addSomeIngredients: "‡Æ§‡Øä‡Æü‡Æô‡Øç‡Æï‡ØÅ‡Æµ‡Æ§‡Æ±‡Øç‡Æï‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øà‡Æö‡Øç ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç!",
    noDescription: "‡Æá‡Æ®‡Øç‡Æ§ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆÆ‡ØÅ‡Æ±‡Øà‡Æï‡Øç‡Æï‡ØÅ ‡Æµ‡Æø‡Æ≥‡Æï‡Øç‡Æï‡ÆÆ‡Øç ‡Æé‡Æ§‡ØÅ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà„ÄÇ",
    recipe: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ",
    backToRecipes: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ",
    defaultCuisine: "‡Æá‡ÆØ‡Æ≤‡Øç‡Æ™‡ØÅ‡Æ®‡Æø‡Æ≤‡Øà ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æµ‡Æï‡Øà", // New translation key
    backToDetails: "‡Æµ‡Æø‡Æµ‡Æ∞‡Æô‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡Æ§‡Øç ‡Æ§‡Æø‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡ØÅ", // New translation for procedure screen
    substitute: "‡Æ™‡Æ§‡Æø‡Æ≤‡ØÄ‡Æü‡ØÅ", // New translation key
    ingredientSubstitutions: "‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Æø‡Æ©‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡ØÄ‡Æü‡ØÅ‡Æï‡Æ≥‡Øç", // New translation key
    creativeRecipeIdea: "‡Æ™‡Æü‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆØ‡Øã‡Æö‡Æ©‡Øà", // New translation key
    generateCreativeIdea: "‡Æ™‡Æü‡Øà‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆØ‡Øã‡Æö‡Æ©‡Øà‡ÆØ‡Øà ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ", // New translation key
    recipeName: "‡Æö‡ÆÆ‡Øà‡ÆØ‡Æ≤‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ ‡Æ™‡ØÜ‡ÆØ‡Æ∞‡Øç", // New translation key
    keyIngredients: "‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ ‡Æ™‡Øä‡Æ∞‡ØÅ‡Æü‡Øç‡Æï‡Æ≥‡Øç", // New translation key
    close: "‡ÆÆ‡ØÇ‡Æü‡ØÅ", // New translation key
    generatingIdea: "‡ÆØ‡Øã‡Æö‡Æ©‡Øà ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ...", // New translation key
    findingSubstitutions: "‡Æ™‡Æ§‡Æø‡Æ≤‡ØÄ‡Æü‡ØÅ‡Æï‡Æ≥‡Øà‡Æï‡Øç ‡Æï‡Æ£‡Øç‡Æü‡Æ±‡Æø‡Æ§‡Æ≤‡Øç...", // New translation key
    shortProcedure: "‡Æï‡ØÅ‡Æ±‡ØÅ‡Æï‡Æø‡ÆØ ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Øç‡ÆÆ‡ØÅ‡Æ±‡Øà", // New translation key
    noIdeaGenerated: "‡Æé‡Æ®‡Øç‡Æ§ ‡ÆØ‡Øã‡Æö‡Æ©‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.", // New translation key
    noSuggestionsFound: "‡Æé‡Æ®‡Øç‡Æ§ ‡Æ™‡Æ∞‡Æø‡Æ®‡Øç‡Æ§‡ØÅ‡Æ∞‡Øà‡Æï‡Æ≥‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà.", // New translation key
  },
  ml: { // Malayalam
    welcomeBack: "‡¥∏‡µç‡¥µ‡¥æ‡¥ó‡¥§‡¥Ç!",
    createAccount: "‡¥Ö‡¥ï‡µç‡¥ï‡µó‡¥£‡µç‡¥ü‡µç ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    loginWithPhone: "‡¥´‡µã‡µ∫ ‡¥®‡¥Æ‡µç‡¥™‡µº ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥≤‡µã‡¥ó‡¥ø‡µª ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
    loginWithGoogle: "‡¥ó‡µÇ‡¥ó‡¥ø‡µæ ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥≤‡µã‡¥ó‡¥ø‡µª ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï", // New translation key
    email: "‡¥á‡¥Æ‡µÜ‡¥Ø‡¥ø‡µΩ",
    password: "‡¥™‡¥æ‡¥∏‡µç‚Äå‡¥µ‡µá‡¥°‡µç",
    loginWithEmail: "‡¥á‡¥Æ‡µÜ‡¥Ø‡¥ø‡µΩ ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥≤‡µã‡¥ó‡¥ø‡µª ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
    dontHaveAccount: "‡¥Ö‡¥ï‡µç‡¥ï‡µó‡¥£‡µç‡¥ü‡µç ‡¥á‡¥≤‡µç‡¥≤‡µá?",
    signUp: "‡¥∏‡µà‡µª ‡¥Ö‡¥™‡µç‡¥™‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï",
    alreadyHaveAccount: "‡¥Æ‡µÅ‡¥Æ‡µç‡¥™‡µá ‡¥Ö‡¥ï‡µç‡¥ï‡µó‡¥£‡µç‡¥ü‡µç ‡¥â‡¥£‡µç‡¥ü‡µã?",
    backToEmailLogin: "‡¥á‡¥Æ‡µÜ‡¥Ø‡¥ø‡µΩ ‡¥≤‡µã‡¥ó‡¥ø‡¥®‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ",
    enterPhoneNumber: "‡¥´‡µã‡µ∫ ‡¥®‡¥Æ‡µç‡¥™‡µº ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï (‡¥â‡¥¶‡¥æ: +919876543210)",
    sendOtp: "OTP ‡¥Ö‡¥Ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    enterVerificationCode: "‡¥∏‡µç‡¥•‡¥ø‡¥∞‡µÄ‡¥ï‡¥∞‡¥£ ‡¥ï‡µã‡¥°‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï", // Used for placeholder
    verifyOtp: "OTP ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡µÄ‡¥ï‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    otpSent: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥´‡µã‡¥£‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç OTP ‡¥Ö‡¥Ø‡¥ö‡µç‡¥ö‡¥ø‡¥ü‡µç‡¥ü‡µÅ‡¥£‡µç‡¥ü‡µç!",
    whatsInKitchen: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥Ö‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡¥≥‡¥Ø‡¥ø‡µΩ ‡¥é‡¥®‡µç‡¥§‡µä‡¥ï‡µç‡¥ï‡µÜ‡¥Ø‡µÅ‡¥£‡µç‡¥ü‡µç?",
    enterIngredient: "‡¥ö‡µá‡¥∞‡µÅ‡¥µ ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï (‡¥â‡¥¶‡¥æ: '‡¥ö‡¥ø‡¥ï‡µç‡¥ï‡µª', '‡¥Ö‡¥∞‡¥ø')",
    addIngredient: "‡¥ö‡µá‡¥∞‡µÅ‡¥µ ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    yourIngredients: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ:",
    clearAll: "‡¥é‡¥≤‡µç‡¥≤‡¥æ‡¥Ç ‡¥Æ‡¥æ‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    selectCuisine: "‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø ‡¥§‡¥ø‡¥∞‡¥û‡µç‡¥û‡µÜ‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡µÅ‡¥ï (‡¥ì‡¥™‡µç‡¥∑‡¥£‡µΩ):",
    anyCuisine: "‡¥è‡¥§‡µç ‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø‡¥Ø‡µÅ‡¥Ç",
    findRecipes: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡µæ ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡µÅ‡¥ï",
    recommendedRecipes: "‡¥∂‡µÅ‡¥™‡¥æ‡µº‡¥∂ ‡¥ö‡µÜ‡¥Ø‡µç‡¥§ ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡µæ",
    backToIngredients: "‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡¥≥‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ",
    ingredients: "‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ",
    description: "‡¥µ‡¥ø‡¥µ‡¥∞‡¥£‡¥Ç",
    startCookingProcedure: "‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø ‡¥Ü‡¥∞‡¥Ç‡¥≠‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    copyRecipe: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç ‡¥™‡¥ï‡µº‡¥§‡µç‡¥§‡µÅ‡¥ï",
    copied: "‡¥™‡¥ï‡µº‡¥§‡µç‡¥§‡¥ø!",
    cookingProcedure: "‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø",
    step: "‡¥ò‡¥ü‡µç‡¥ü‡¥Ç",
    previousStep: "‡¥Æ‡µÅ‡¥Æ‡µç‡¥™‡¥§‡µç‡¥§‡µÜ ‡¥ò‡¥ü‡µç‡¥ü‡¥Ç",
    nextStep: "‡¥Ö‡¥ü‡µÅ‡¥§‡µç‡¥§ ‡¥ò‡¥ü‡µç‡¥ü‡¥Ç",
    finishCooking: "‡¥™‡¥æ‡¥ö‡¥ï‡¥Ç ‡¥™‡µÇ‡µº‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥ï!",
    congratulations: "üéâ ‡¥Ö‡¥≠‡¥ø‡¥®‡¥®‡µç‡¥¶‡¥®‡¥ô‡µç‡¥ô‡µæ! üéâ",
    recipeCompleted: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥™‡µÇ‡µº‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥æ‡¥ï‡µç‡¥ï‡¥ø‡¥Ø‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ:",
    cookAnotherRecipe: "‡¥Æ‡¥±‡µç‡¥±‡µä‡¥∞‡µÅ ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    logout: "‡¥™‡µÅ‡¥±‡¥§‡µç‡¥§‡µÅ‡¥ï‡¥ü‡¥ï‡µç‡¥ï‡µÅ‡¥ï",
    loadingApp: "‡¥Ü‡¥™‡µç‡¥™‡µç ‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ...",
    error: "‡¥™‡¥ø‡¥∂‡¥ï‡µç:",
    pleaseAddIngredient: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡µæ ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡¥æ‡µª ‡¥ï‡µÅ‡¥±‡¥û‡µç‡¥û‡¥§‡µç ‡¥í‡¥∞‡µÅ ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥Ø‡µÜ‡¥ô‡µç‡¥ï‡¥ø‡¥≤‡µÅ‡¥Ç ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    failedToFetchRecipes: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡µæ ‡¥≤‡¥≠‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ:",
    noRecipesFound: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ‡¥ï‡µç‡¥ï‡µÅ‡¥Ç ‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥Ç ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡¥≥‡µä‡¥®‡µç‡¥®‡µÅ‡¥Ç ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥ø‡¥≤‡µç‡¥≤. ‡¥ï‡µÇ‡¥ü‡µÅ‡¥§‡µΩ ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï ‡¥Ö‡¥≤‡µç‡¥≤‡µÜ‡¥ô‡µç‡¥ï‡¥ø‡µΩ ‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡µÅ‡¥ï!",
    settings: "‡¥ï‡µç‡¥∞‡¥Æ‡µÄ‡¥ï‡¥∞‡¥£‡¥ô‡µç‡¥ô‡µæ",
    language: "‡¥≠‡¥æ‡¥∑",
    popularDishes: "‡¥™‡µç‡¥∞‡¥∂‡¥∏‡µç‡¥§ ‡¥µ‡¥ø‡¥≠‡¥µ‡¥ô‡µç‡¥ô‡µæ",
    viewPopularDishes: "‡¥™‡µç‡¥∞‡¥∂‡¥∏‡µç‡¥§ ‡¥µ‡¥ø‡¥≠‡¥µ‡¥ô‡µç‡¥ô‡µæ ‡¥ï‡¥æ‡¥£‡µÅ‡¥ï",
    backToHome: "‡¥π‡µã‡¥Æ‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ",
    noInstructions: "‡¥à ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥®‡µç ‡¥µ‡¥ø‡¥∂‡¥¶‡¥Æ‡¥æ‡¥Ø ‡¥®‡¥ø‡µº‡¥¶‡µç‡¥¶‡µá‡¥∂‡¥ô‡µç‡¥ô‡¥≥‡µä‡¥®‡µç‡¥®‡µÅ‡¥Ç ‡¥≤‡¥≠‡µç‡¥Ø‡¥Æ‡¥≤‡µç‡¥≤.",
    failedToLoadUserData: "‡¥â‡¥™‡¥Ø‡µã‡¥ï‡µç‡¥§‡µÉ ‡¥°‡¥æ‡¥±‡µç‡¥± ‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    failedToSaveIngredient: "‡¥ï‡µç‡¥≤‡µó‡¥°‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥ö‡µá‡¥∞‡µÅ‡¥µ ‡¥∏‡¥Ç‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    failedToRemoveIngredient: "‡¥ï‡µç‡¥≤‡µó‡¥°‡¥ø‡µΩ ‡¥®‡¥ø‡¥®‡µç‡¥®‡µç ‡¥ö‡µá‡¥∞‡µÅ‡¥µ ‡¥®‡µÄ‡¥ï‡µç‡¥ï‡¥Ç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    failedToClearIngredients: "‡¥ï‡µç‡¥≤‡µó‡¥°‡¥ø‡¥≤‡µÜ ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ ‡¥Æ‡¥æ‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    securityCheckNotReady: "‡¥∏‡µÅ‡¥∞‡¥ï‡µç‡¥∑‡¥æ ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥§‡¥Ø‡µç‡¥Ø‡¥æ‡¥±‡¥≤‡µç‡¥≤. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    firebaseAuthNotInitialized: "‡¥´‡¥Ø‡µº‡¥¨‡µá‡¥∏‡µç ‡¥ì‡¥§‡¥®‡µç‡¥±‡¥ø‡¥ï‡µç‡¥ï‡µá‡¥∑‡µª ‡¥Ü‡¥∞‡¥Ç‡¥≠‡¥ø‡¥ö‡µç‡¥ö‡¥ø‡¥ü‡µç‡¥ü‡¥ø‡¥≤‡µç‡¥≤.",
    pleaseSendOtpFirst: "‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥Ü‡¥¶‡µç‡¥Ø‡¥Ç OTP ‡¥Ö‡¥Ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    enterVerificationCodeError: "‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥∏‡µç‡¥•‡¥ø‡¥∞‡µÄ‡¥ï‡¥∞‡¥£ ‡¥ï‡µã‡¥°‡µç ‡¥®‡µΩ‡¥ï‡µÅ‡¥ï„ÄÇ", // Used for error message
    otpExpired: "‡¥±‡µÄ‡¥ï‡¥æ‡¥™‡µç‡¥ö‡¥Ø‡µÅ‡¥ü‡µÜ ‡¥ï‡¥æ‡¥≤‡¥æ‡¥µ‡¥ß‡¥ø ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø OTP ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥Ö‡¥Ø‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.",
    failedToLoadSecurity: "‡¥∏‡µÅ‡¥∞‡¥ï‡µç‡¥∑‡¥æ ‡¥™‡¥∞‡¥ø‡¥∂‡µã‡¥ß‡¥® ‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡¥ø‡µΩ ‡¥™‡¥∞‡¥æ‡¥ú‡¥Ø‡¥™‡µç‡¥™‡µÜ‡¥ü‡µç‡¥ü‡µÅ. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥±‡µÄ‡¥´‡µç‡¥∞‡¥∑‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï„ÄÇ",
    translatingContent: "‡¥â‡¥≥‡µç‡¥≥‡¥ü‡¥ï‡µç‡¥ï‡¥Ç ‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ",
    yourDish: "‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥µ‡¥ø‡¥≠‡¥µ‡¥Ç",
    addSomeIngredients: "‡¥§‡µÅ‡¥ü‡¥ô‡µç‡¥ô‡¥æ‡µª ‡¥ö‡¥ø‡¥≤ ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï!",
    noDescription: "‡¥à ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡¥ø‡¥®‡µç ‡¥µ‡¥ø‡¥µ‡¥∞‡¥£‡¥Ç ‡¥≤‡¥≠‡µç‡¥Ø‡¥Æ‡¥≤‡µç‡¥≤.",
    recipe: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç",
    backToRecipes: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µÅ‡¥ï‡¥≥‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ",
    defaultCuisine: "‡¥∏‡µç‡¥•‡¥ø‡¥∞‡¥∏‡µç‡¥•‡¥ø‡¥§‡¥ø ‡¥™‡¥æ‡¥ö‡¥ï‡¥∞‡µÄ‡¥§‡¥ø", // New translation key
    backToDetails: "‡¥µ‡¥ø‡¥µ‡¥∞‡¥ô‡µç‡¥ô‡¥≥‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ", // New translation for procedure screen
    substitute: "‡¥™‡¥ï‡¥∞‡¥Æ‡µÅ‡¥≥‡µç‡¥≥‡¥§‡µç", // New translation key
    ingredientSubstitutions: "‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ‡¥ï‡µç‡¥ï‡µç ‡¥™‡¥ï‡¥∞‡¥Æ‡µÅ‡¥≥‡µç‡¥≥‡¥µ", // New translation key
    creativeRecipeIdea: "‡¥ï‡µç‡¥∞‡¥ø‡¥Ø‡µá‡¥±‡µç‡¥±‡µÄ‡¥µ‡µç ‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç ‡¥Ü‡¥∂‡¥Ø‡¥Ç", // New translation key
    generateCreativeIdea: "‡¥ï‡µç‡¥∞‡¥ø‡¥Ø‡¥æ‡¥§‡µç‡¥Æ‡¥ï ‡¥Ü‡¥∂‡¥Ø‡¥Ç ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥ï", // New translation key
    recipeName: "‡¥™‡¥æ‡¥ö‡¥ï‡¥ï‡µç‡¥ï‡µÅ‡¥±‡¥ø‡¥™‡µç‡¥™‡µç ‡¥™‡µá‡¥∞‡µç", // New translation key
    keyIngredients: "‡¥™‡µç‡¥∞‡¥ß‡¥æ‡¥® ‡¥ö‡µá‡¥∞‡µÅ‡¥µ‡¥ï‡µæ", // New translation key
    close: "‡¥Ö‡¥ü‡¥Ø‡µç‡¥ï‡µç‡¥ï‡µÅ‡¥ï", // New translation key
    generatingIdea: "‡¥Ü‡¥∂‡¥Ø‡¥Ç ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ...", // New translation key
    findingSubstitutions: "‡¥™‡¥ï‡¥∞‡¥Æ‡µÅ‡¥≥‡µç‡¥≥‡¥µ ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡µÅ‡¥®‡µç‡¥®‡µÅ...", // New translation key
    shortProcedure: "‡¥ö‡µÅ‡¥∞‡µÅ‡¥ï‡µç‡¥ï‡¥ø‡¥Ø ‡¥®‡¥ü‡¥™‡¥ü‡¥ø‡¥ï‡µç‡¥∞‡¥Æ‡¥Ç", // New translation key
    noIdeaGenerated: "‡¥í‡¥∞‡µÅ ‡¥Ü‡¥∂‡¥Ø‡¥µ‡µÅ‡¥Ç ‡¥∏‡µÉ‡¥∑‡µç‡¥ü‡¥ø‡¥ö‡µç‡¥ö‡¥ø‡¥≤‡µç‡¥≤.", // New translation key
    noSuggestionsFound: "‡¥®‡¥ø‡µº‡¥¶‡µç‡¥¶‡µá‡¥∂‡¥ô‡µç‡¥ô‡¥≥‡µä‡¥®‡µç‡¥®‡µÅ‡¥Ç ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥ø‡¥≤‡µç‡¥≤.", // New translation key
  },
  te: { // Telugu
    welcomeBack: "‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø ‡∞∏‡±ç‡∞µ‡∞æ‡∞ó‡∞§‡∞Ç!",
    createAccount: "‡∞ñ‡∞æ‡∞§‡∞æ‡∞®‡±Å ‡∞∏‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
    loginWithPhone: "‡∞´‡±ã‡∞®‡±ç ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
    loginWithGoogle: "‡∞ó‡±Ç‡∞ó‡±Å‡∞≤‡±ç ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø", // New translation key
    email: "‡∞á‡∞Æ‡±Ü‡∞Ø‡∞ø‡∞≤‡±ç",
    password: "‡∞™‡∞æ‡∞∏‡±ç‚Äå‡∞µ‡∞∞‡±ç‡∞°‡±ç",
    loginWithEmail: "‡∞á‡∞Æ‡±Ü‡∞Ø‡∞ø‡∞≤‡±ç ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
    dontHaveAccount: "‡∞ñ‡∞æ‡∞§‡∞æ ‡∞≤‡±á‡∞¶‡∞æ?",
    signUp: "‡∞∏‡±à‡∞®‡±ç ‡∞Ö‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
    alreadyHaveAccount: "‡∞á‡∞™‡±ç‡∞™‡∞ü‡∞ø‡∞ï‡±á ‡∞ñ‡∞æ‡∞§‡∞æ ‡∞â‡∞Ç‡∞¶‡∞æ?",
    backToEmailLogin: "‡∞á‡∞Æ‡±Ü‡∞Ø‡∞ø‡∞≤‡±ç ‡∞≤‡∞æ‡∞ó‡∞ø‡∞®‡±ç‚Äå‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø",
    enterPhoneNumber: "‡∞´‡±ã‡∞®‡±ç ‡∞®‡∞Ç‡∞¨‡∞∞‡±ç ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (‡∞â‡∞¶‡∞æ: +919876543210)",
    sendOtp: "OTP ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø",
    enterVerificationCode: "‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞ï‡±ã‡∞°‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø", // Used for placeholder
    verifyOtp: "OTP ‡∞®‡∞ø ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
    otpSent: "‡∞Æ‡±Ä ‡∞´‡±ã‡∞®‡±ç‚Äå‡∞ï‡±Å OTP ‡∞™‡∞Ç‡∞™‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø!",
    whatsInKitchen: "‡∞Æ‡±Ä ‡∞µ‡∞Ç‡∞ü‡∞ó‡∞¶‡∞ø‡∞≤‡±ã ‡∞è‡∞Æ‡±Å‡∞Ç‡∞¶‡∞ø?",
    enterIngredient: "‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞Ç ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (‡∞â‡∞¶‡∞æ: '‡∞ö‡∞ø‡∞ï‡±Ü‡∞®‡±ç', '‡∞¨‡∞ø‡∞Ø‡±ç‡∞Ø‡∞Ç')",
    addIngredient: "‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞Ç ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
    yourIngredients: "‡∞Æ‡±Ä ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å:",
    clearAll: "‡∞Ö‡∞®‡±ç‡∞®‡∞ø‡∞Ç‡∞ü‡∞ø‡∞®‡±Ä ‡∞ï‡±ç‡∞≤‡∞ø‡∞Ø‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
    selectCuisine: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç ‡∞é‡∞Ç‡∞ö‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø (‡∞ê‡∞ö‡±ç‡∞õ‡∞ø‡∞ï‡∞Ç):",
    anyCuisine: "‡∞è ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç ‡∞Ö‡∞Ø‡∞ø‡∞®‡∞æ",
    findRecipes: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡∞®‡±Å ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞Ç‡∞°‡∞ø",
    recommendedRecipes: "‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡±ç‡∞∏‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞® ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡±Å",
    backToIngredients: "‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø",
    ingredients: "‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å",
    description: "‡∞µ‡∞ø‡∞µ‡∞∞‡∞£",
    startCookingProcedure: "‡∞µ‡∞Ç‡∞ü ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø",
    copyRecipe: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞ï‡∞æ‡∞™‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø",
    copied: "‡∞ï‡∞æ‡∞™‡±Ä ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø!",
    cookingProcedure: "‡∞µ‡∞Ç‡∞ü ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞Ç",
    step: "‡∞¶‡∞∂",
    previousStep: "‡∞Æ‡±Å‡∞®‡±Å‡∞™‡∞ü‡∞ø ‡∞¶‡∞∂",
    nextStep: "‡∞§‡∞¶‡±Å‡∞™‡∞∞‡∞ø ‡∞¶‡∞∂",
    finishCooking: "‡∞µ‡∞Ç‡∞ü ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø!",
    congratulations: "üéâ ‡∞Ö‡∞≠‡∞ø‡∞®‡∞Ç‡∞¶‡∞®‡∞≤‡±Å! üéâ",
    recipeCompleted: "‡∞Æ‡±Ä‡∞∞‡±Å ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞µ‡∞ø‡∞ú‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Ç‡∞ó‡∞æ ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞ö‡±á‡∞∏‡∞æ‡∞∞‡±Å:",
    cookAnotherRecipe: "‡∞Æ‡∞∞‡±ä‡∞ï ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç ‡∞µ‡∞Ç‡∞°‡∞Ç‡∞°‡∞ø",
    logout: "‡∞≤‡∞æ‡∞ó‡±ç ‡∞Ö‡∞µ‡±Å‡∞ü‡±ç",
    loadingApp: "‡∞Ø‡∞æ‡∞™‡±ç ‡∞≤‡±ã‡∞°‡±ç ‡∞Ö‡∞µ‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø...",
    error: "‡∞≤‡±ã‡∞™‡∞Ç:",
    pleaseAddIngredient: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡∞®‡±Å ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞ï‡∞®‡±Ä‡∞∏‡∞Ç ‡∞í‡∞ï ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
    failedToFetchRecipes: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡∞®‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø:",
    noRecipesFound: "‡∞Æ‡±Ä ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡±Å ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å. ‡∞Æ‡∞∞‡∞ø‡∞®‡±ç‡∞®‡∞ø ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ö‡∞Ç‡∞°‡∞ø!",
    settings: "‡∞∏‡±Ü‡∞ü‡±ç‡∞ü‡∞ø‡∞Ç‡∞ó‡±ç‚Äå‡∞≤‡±Å",
    language: "‡∞≠‡∞æ‡∞∑",
    popularDishes: "‡∞™‡±ç‡∞∞‡∞∏‡∞ø‡∞¶‡±ç‡∞ß ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡±Å",
    viewPopularDishes: "‡∞™‡±ç‡∞∞‡∞∏‡∞ø‡∞¶‡±ç‡∞ß ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡∞®‡±Å ‡∞ö‡±Ç‡∞°‡∞Ç‡∞°‡∞ø",
    backToHome: "‡∞π‡±ã‡∞Æ‡±ç‚Äå‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø",
    noInstructions: "‡∞à ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞µ‡∞ø‡∞µ‡∞∞‡∞£‡∞æ‡∞§‡±ç‡∞Æ‡∞ï ‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å ‡∞Ö‡∞Ç‡∞¶‡±Å‡∞¨‡∞æ‡∞ü‡±Å‡∞≤‡±ã ‡∞≤‡±á‡∞µ‡±Å„ÄÇ",
    failedToClearIngredients: "‡∞ï‡±ç‡∞≤‡±å‡∞°‡±ç‚Äå‡∞≤‡±ã‡∞®‡∞ø ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡∞®‡±Å ‡∞ï‡±ç‡∞≤‡∞ø‡∞Ø‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø„ÄÇ",
    securityCheckNotReady: "‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞∏‡∞ø‡∞¶‡±ç‡∞ß‡∞Ç‡∞ó‡∞æ ‡∞≤‡±á‡∞¶‡±Å. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø„ÄÇ",
    firebaseAuthNotInitialized: "‡∞´‡±à‡∞∞‡±ç‚Äå‡∞¨‡±á‡∞∏‡±ç ‡∞™‡±ç‡∞∞‡∞Æ‡∞æ‡∞£‡±Ä‡∞ï‡∞∞‡∞£ ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å„ÄÇ",
    pleaseSendOtpFirst: "‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡±Å‡∞Ç‡∞¶‡±Å‡∞ó‡∞æ OTP ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø„ÄÇ",
    enterVerificationCodeError: "‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞ï‡±ã‡∞°‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø„ÄÇ", // Used for error message
    otpExpired: "‡∞∞‡±Ä‡∞ï‡±ç‡∞Ø‡∞æ‡∞™‡±ç‡∞ö‡∞æ ‡∞ó‡∞°‡±Å‡∞µ‡±Å ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø OTP ‡∞®‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞™‡∞Ç‡∞™‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø„ÄÇ",
    failedToLoadSecurity: "‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä‡∞®‡∞ø ‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞∞‡∞ø‡∞´‡±ç‡∞∞‡±Ü‡∞∑‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø„ÄÇ",
    translatingContent: "‡∞ï‡∞Ç‡∞ü‡±Ü‡∞Ç‡∞ü‡±ç ‡∞Ö‡∞®‡±Å‡∞µ‡∞¶‡∞ø‡∞∏‡±ç‡∞§‡±ã‡∞Ç‡∞¶‡∞ø",
    yourDish: "‡∞Æ‡±Ä ‡∞°‡∞ø‡∞∑‡±ç",
    addSomeIngredients: "‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞ï‡±ä‡∞®‡±ç‡∞®‡∞ø ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡∞®‡±Å ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø!",
    noDescription: "‡∞à ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞µ‡∞ø‡∞µ‡∞∞‡∞£ ‡∞Ö‡∞Ç‡∞¶‡±Å‡∞¨‡∞æ‡∞ü‡±Å‡∞≤‡±ã ‡∞≤‡±á‡∞¶‡±Å„ÄÇ",
    recipe: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç",
    backToRecipes: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞æ‡∞≤‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø",
    defaultCuisine: "‡∞°‡∞ø‡∞´‡∞æ‡∞≤‡±ç‡∞ü‡±ç ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç", // New translation key
    backToDetails: "‡∞µ‡∞ø‡∞µ‡∞∞‡∞æ‡∞≤‡∞ï‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø", // New translation for procedure screen
    substitute: "‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞æ‡∞Æ‡±ç‡∞®‡∞æ‡∞Ø‡∞Ç", // New translation key
    ingredientSubstitutions: "‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞• ‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞æ‡∞Æ‡±ç‡∞®‡∞æ‡∞Ø‡∞æ‡∞≤‡±Å", // New translation key
    creativeRecipeIdea: "‡∞ï‡±ç‡∞∞‡∞ø‡∞Ø‡±á‡∞ü‡∞ø‡∞µ‡±ç ‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç ‡∞Ü‡∞≤‡±ã‡∞ö‡∞®", // New translation key
    generateCreativeIdea: "‡∞ï‡±ç‡∞∞‡∞ø‡∞Ø‡±á‡∞ü‡∞ø‡∞µ‡±ç ‡∞Ü‡∞≤‡±ã‡∞ö‡∞®‡∞®‡±Å ‡∞∞‡±Ç‡∞™‡±ä‡∞Ç‡∞¶‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø", // New translation key
    recipeName: "‡∞µ‡∞Ç‡∞ü‡∞ï‡∞Ç ‡∞™‡±á‡∞∞‡±Å", // New translation key
    keyIngredients: "‡∞ï‡±Ä ‡∞™‡∞¶‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å", // New translation key
    close: "‡∞Æ‡±Ç‡∞∏‡∞ø‡∞µ‡±á‡∞Ø‡∞ø", // New translation key
    generatingIdea: "‡∞Ü‡∞≤‡±ã‡∞ö‡∞®‡∞®‡±Å ‡∞∞‡±Ç‡∞™‡±ä‡∞Ç‡∞¶‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø...", // New translation key
    findingSubstitutions: "‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞æ‡∞Æ‡±ç‡∞®‡∞æ‡∞Ø‡∞æ‡∞≤‡∞®‡±Å ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞Ç‡∞ü‡±Å‡∞Ç‡∞¶‡∞ø...", // New translation key
    shortProcedure: "‡∞ö‡∞ø‡∞®‡±ç‡∞® ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞Ç", // New translation key
    noIdeaGenerated: "‡∞Ü‡∞≤‡±ã‡∞ö‡∞® ‡∞∞‡±Ç‡∞™‡±ä‡∞Ç‡∞¶‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å.", // New translation key
    noSuggestionsFound: "‡∞∏‡±Ç‡∞ö‡∞®‡∞≤‡±Å ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å.", // New translation key
  },
};


// CSS for custom animations (fadeIn, steam, stir, confetti)
const customAnimationsCss = `
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes steam {
  0% { transform: translateY(0px) translateX(0px); opacity: 0.8; }
  25% { transform: translateY(-5px) translateX(2px); opacity: 0.6; }
  50% { transform: translateY(-10px) translateX(-2px); opacity: 0.4; }
  75% { transform: translateY(-15px) translateX(2px); opacity: 0.2; }
  100% { transform: translateY(-20px) translateX(-2px); opacity: 0; }
}

@keyframes stir {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes confetti-fall {
  0% {
    transform: translateY(-100vh) rotate(0deg);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

.animate-fadeIn {
  animation: fadeIn 0.5s ease-out forwards;
}
.animate-steam {
  animation: steam 1.5s infinite ease-out;
}
.delay-100 {
  animation-delay: 0.1s;
}
.animate-stir {
  animation: stir 2s linear infinite;
  transform-origin: 50% 50%; /* Center of the pot */
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: var(--confetti-color);
  animation: confetti-fall var(--animation-duration) ease-out forwards;
  opacity: 0;
  border-radius: 50%;
  box-shadow: 0 0 5px rgba(0,0,0,0.2);
  z-index: 9999; /* Ensure confetti is on top */
}
.animate-bounce-in {
  animation: bounceIn 0.8s ease-out;
}
@keyframes bounceIn {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.05); opacity: 1; }
  70% { transform: scale(0.9); }
  100% { transform: scale(1); }
}
`;

// Loading Skeleton Component
const RecipeCardSkeleton = () => (
  <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-xl overflow-hidden mb-6 w-full shadow-xl animate-pulse border-2 border-gray-200 border-opacity-60">
    <div className="w-full h-56 bg-gray-300"></div>
    <div className="p-5">
      <div className="h-6 bg-gray-300 rounded w-3/4 mb-2"></div>
      <div className="h-4 bg-gray-300 rounded w-full mb-3"></div>
      <div className="h-4 bg-gray-300 rounded w-1/2"></div>
    </div>
  </div>
);

// Cooking Animation Component
const CookingAnimation = ({ step }) => {
  let svgContent = null;
  const animationType = step % 4; // Cycles through 4 animation types

  switch (animationType) {
    case 0: // Initial/Prep/Chopping
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <rect x="10" y="70" width="80" height="20" fill="#8B4513" rx="5" ry="5" /> {/* Cutting board */}
          <path d="M 70 60 L 60 80 L 80 80 Z" fill="#32CD32" /> {/* Veggie piece 1 */}
          <path d="M 50 65 L 40 75 L 60 75 Z" fill="#FFD700" /> {/* Veggie piece 2 */}
          <path d="M 40 50 L 35 70 L 55 70 Z" fill="#FF6347" /> {/* Veggie piece 3 */}
          <line x1="85" y1="50" x2="75" y2="70" stroke="#A9A9A9" strokeWidth="3" strokeLinecap="round" /> {/* Knife handle */}
          <line x1="75" y1="70" x2="65" y2="70" stroke="#D3D3D3" strokeWidth="3" strokeLinecap="round" /> {/* Knife blade */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Prepare Ingredients</text>
        </svg>
      );
      break;
    case 1: // Heating/Frying/Saut√©ing
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <rect x="25" y="60" width="50" height="20" fill="#A9A9A9" rx="5" ry="5" /> {/* Stove top */}
          <circle cx="50" cy="50" r="20" fill="#D3D3D3" stroke="#808080" strokeWidth="2" /> {/* Pan */}
          <circle cx="50" cy="50" r="15" fill="#FF8C00" /> {/* Heat/Oil */}
          <path d="M 50 30 Q 55 20 60 30" stroke="#fff" strokeWidth="2" fill="none" className="animate-steam" /> {/* Steam 1 */}
          <path d="M 40 35 Q 45 25 50 35" stroke="#fff" strokeWidth="2" fill="none" className="animate-steam delay-100" /> {/* Steam 2 */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Heat & Cook</text>
        </svg>
      );
      break;
    case 2: // Stirring/Mixing
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="50" r="25" fill="#A9A9A9" stroke="#808080" strokeWidth="2" /> {/* Pot */}
          <rect x="40" y="75" width="20" height="5" fill="#8B4513" /> {/* Pot handle */}
          <path d="M 60 40 L 70 30 L 80 40" stroke="#8B4513" strokeWidth="3" strokeLinecap="round" /> {/* Spoon handle */}
          <circle cx="80" cy="40" r="5" fill="#8B4513" /> {/* Spoon head */}
          <animateTransform
            attributeName="transform"
            attributeType="XML"
            type="rotate"
            from="0 50 50"
            to="360 50 50"
            dur="2s"
            repeatCount="indefinite"
            className="animate-stir"
          />
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Stirring</text>
        </svg>
      );
      break;
    case 3: // Serving/Dish Ready
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="70" r="30" fill="#fff" stroke="#ccc" strokeWidth="2" /> {/* Plate */}
          <path d="M 30 60 Q 50 30 70 60 Q 50 90 30 60 Z" fill="#FFD700" stroke="#FF8C00" strokeWidth="2" /> {/* Food */}
          <path d="M 40 65 Q 50 40 60 65" fill="#32CD32" /> {/* Garnish */}
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Dish Ready!</text>
        </svg>
      );
      break;
    default: // Fallback for any other step, maybe a generic cooking icon
      svgContent = (
        <svg width="100%" height="100%" viewBox="0 0 100 100" className="animate-fadeIn">
          <circle cx="50" cy="50" r="40" fill="#eee" stroke="#ccc" strokeWidth="2" />
          <path d="M 30 50 L 70 50 M 50 30 L 50 70" stroke="#aaa" strokeWidth="5" strokeLinecap="round" />
          <text x="50" y="20" fontSize="12" fill="#555" textAnchor="middle">Cooking Action</text>
        </svg>
      );
  }

  return (
    <div className="w-full h-full flex items-center justify-center">
      {svgContent}
    </div>
  );
};


const App = () => {
  const [currentScreen, setCurrentScreen] = useState(SCREENS.LOGIN); // Start at login screen
  const [ingredientsInput, setIngredientsInput] = useState('');
  const [userIngredients, setUserIngredients] = useState([]);
  const [recommendedRecipes, setRecommendedRecipes] = useState([]);
  const [selectedRecipe, setSelectedRecipe] = useState(null); // Corrected: Initialized with useState(null)
  const [loading, setLoading] = useState(false);
  const [currentProcedureStep, setCurrentProcedureStep] = useState(0);
  const [apiError, setApiError] = useState(null);
  const [selectedCuisine, setSelectedCuisine] = useState(''); // Default to empty string for "Any Cuisine"
  const [showCopiedMessage, setShowCopiedMessage] = useState(false);
  const [translationLoading, setTranslationLoading] = useState(false); // New state for translation loading

  // Firebase Auth States
  const [currentUser, setCurrentUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [authError, setAuthError] = useState(null);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Phone Auth States
  const [phoneNumber, setPhoneNumber] = useState('');
  const [verificationCode, setVerificationCode] = useState('');
  const [confirmationResult, setConfirmationResult] = useState(null); // Stores the result of sending OTP
  const recaptchaRef = useRef(null); // Ref for Recaptcha container
  const [recaptchaVerifier, setRecaptchaVerifier] = useState(null); // Stores the RecaptchaVerifier instance
  const [showOtpSentMessage, setShowOtpSentMessage] = useState(false); // New state for OTP sent message

  // LLM Feature States
  const [showSubstitutionModal, setShowSubstitutionModal] = useState(false);
  const [substitutionResult, setSubstitutionResult] = null;
  const [substitutingIngredient, setSubstitutingIngredient] = useState('');
  const [showCreativeRecipeModal, setShowCreativeRecipeModal] = useState(false);
  const [creativeRecipeIdea, setCreativeRecipeIdea] = useState(null);
  const [llmLoading, setLlmLoading] = useState(false); // Combined loading for LLM features

  // For animation, we'll use a simple CSS transition via state for opacity
  const [stepOpacity, setStepOpacity] = useState(1);
  const confettiContainerRef = useRef(null); // Ref for confetti container

  // Use useState for app, auth, and db instances to ensure they are reactive
  const [appInstance, setAppInstance] = useState(null);
  const [authInstance, setAuthInstance] = useState(null);
  const [dbInstance, setDbInstance] = useState(null);

  // New state for language selection, default to English
  const [language, setLanguage] = useState('en');

  // Helper function to get translated text
  const getTranslatedText = (key) => {
    return translations[language]?.[key] || translations.en[key] || key;
  };

  // Firebase Configuration - YOUR ACTUAL CONFIG IS HERE!
  // REPLACE THESE VALUES WITH YOUR PROJECT'S CONFIG FROM FIREBASE CONSOLE
  const firebaseConfig = {
    apiKey: "AIzaSyC-dFXiWiQXctEvSZPPPwVb_WEIsz-DGmc",
    authDomain: "curry-craft-daf8f.firebaseapp.com",
    projectId: "curry-craft-daf8f",
    storageBucket: "curry-craft-daf8f.firebasestorage.app",
    messagingSenderId: "905032476877",
    appId: "1:905032476877:web:1d5434f1fcbc86532fe184",
    measurementId: "G-VX5E06M3TN"
  };

  // Firebase Initialization and Auth Listener
  useEffect(() => {
    try {
      const initializedApp = initializeApp(firebaseConfig);
      const initializedAuth = getAuth(initializedApp);
      const initializedDb = getFirestore(initializedApp);

      setAppInstance(initializedApp);
      setAuthInstance(initializedAuth);
      setDbInstance(initializedDb);

      const unsubscribe = onAuthStateChanged(initializedAuth, async (user) => {
        if (user) {
          setCurrentUser(user);
          try {
            const userDocRef = doc(initializedDb, "users", user.uid);
            const userDocSnap = await getDoc(userDocRef);

            if (userDocSnap.exists()) {
              const userData = userDocSnap.data();
              setUserIngredients(userData.userIngredients || []);
              // Set user's preferred language if stored, otherwise default
              setLanguage(userData.preferences?.language || 'en');
              // Set user's preferred cuisine if stored, otherwise default to empty (Any Cuisine)
              setSelectedCuisine(userData.preferences?.cuisine || '');
              console.log("User data loaded from Firestore:", userData);
            } else {
              console.log("No existing user document found. Creating one.");
              await setDoc(userDocRef, {
                  email: user.email || user.phoneNumber || user.providerData[0]?.email || 'N/A', // Handle Google email
                  userIngredients: [],
                  savedRecipeIds: [],
                  preferences: { cuisine: '', language: 'en' }, // Default to Any Cuisine
                  createdAt: new Date()
              });
              setUserIngredients([]);
              setLanguage('en');
              setSelectedCuisine(''); // Set default cuisine on new user creation
            }
          } catch (firestoreError) {
            console.error("Error loading user data from Firestore:", firestoreError);
            setApiError(getTranslatedText("failedToLoadUserData"));
            setUserIngredients([]);
          }
          if ([SCREENS.LOGIN, SCREENS.SIGNUP, SCREENS.PHONE_LOGIN].includes(currentScreen)) {
            setCurrentScreen(SCREENS.HOME);
          }
        } else {
          setCurrentUser(null);
          setUserIngredients([]);
          setCurrentScreen(SCREENS.LOGIN);
          // --- CRITICAL FIX START ---
          // Attempt to sign in with custom token if available (for Canvas environment)
          // Otherwise, sign in anonymously. This ensures all users are authenticated for Firestore.
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            try {
              await signInWithCustomToken(initializedAuth, __initial_auth_token);
              console.log("Signed in with custom token.");
            } catch (tokenError) {
              console.error("Error signing in with custom token, falling back to anonymous:", tokenError);
              try {
                await signInAnonymously(initializedAuth);
                console.log("Signed in anonymously.");
              } catch (anonError) {
                console.error("Error signing in anonymously:", anonError);
                setAuthError("Authentication failed. Please try again.");
              }
            }
          } else {
            // If no custom token is provided (e.g., local development outside Canvas)
            try {
              await signInAnonymously(initializedAuth);
              console.log("Signed in anonymously (no custom token).");
            } catch (anonError) {
              console.error("Error signing in anonymously:", anonError);
              setAuthError("Authentication failed. Please try again.");
            }
          }
          // --- CRITICAL FIX END ---
        }
        setAuthLoading(false);
      });
      return () => unsubscribe();
    } catch (e) {
      console.error("Error initializing Firebase:", e);
      setAuthError(getTranslatedText("failedToInitAuth"));
      setAuthLoading(false);
      setCurrentScreen(SCREENS.HOME);
    }
  }, []);

  // Effect to update user's language and cuisine preference in Firestore
  useEffect(() => {
    if (currentUser && dbInstance) {
      const userDocRef = doc(dbInstance, "users", currentUser.uid);
      updateDoc(userDocRef, {
        'preferences.language': language,
        'preferences.cuisine': selectedCuisine // Persist selectedCuisine from Home/Settings
      }).catch(error => {
        console.error("Error updating user preferences:", error);
      });
    }
  }, [language, selectedCuisine, currentUser, dbInstance]);


  // Initialize RecaptchaVerifier when the phone login screen is active AND authInstance is available
  useEffect(() => {
    if (authInstance && currentScreen === SCREENS.PHONE_LOGIN && recaptchaRef.current && !recaptchaVerifier) {
      try {
        const verifier = new RecaptchaVerifier(authInstance, recaptchaRef.current, {
          'size': 'invisible',
          'callback': (response) => {
            console.log("Recaptcha solved!");
          },
          'expired-callback': () => {
            console.warn("Recaptcha expired.");
            setAuthError(getTranslatedText("otpExpired"));
            setRecaptchaVerifier(null);
          }
        });
        verifier.render().then((widgetId) => {
          console.log("Recaptcha rendered:", widgetId);
        });
        setRecaptchaVerifier(verifier);
      } catch (error) {
        console.error("Error initializing Recaptcha:", error);
        setAuthError(getTranslatedText("failedToLoadSecurity"));
      }
    }
  }, [authInstance, currentScreen, recaptchaVerifier, recaptchaRef, getTranslatedText]);


  useEffect(() => {
    if (currentScreen === SCREENS.PROCEDURE) {
      setStepOpacity(0);
      const timer = setTimeout(() => {
        setStepOpacity(1);
      }, 100);
      return () => clearTimeout(timer);
    }
    if (currentScreen === SCREENS.COMPLETED) {
      generateConfetti();
    }
  }, [currentProcedureStep, currentScreen]);

  // Function to generate confetti
  const generateConfetti = () => {
    if (!confettiContainerRef.current) return;

    const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];
    const numConfetti = 50;

    for (let i = 0; i < numConfetti; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.setProperty('--confetti-color', colors[Math.floor(Math.random() * colors.length)]);
      confetti.style.left = `${Math.random() * 100}vw`;
      confetti.style.top = `${Math.random() * -20}vh`;
      confetti.style.animationDuration = `${2 + Math.random() * 3}s`;
      confetti.style.animationDelay = `${Math.random() * 0.5}s`;
      confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

      confettiContainerRef.current.appendChild(confetti);

      confetti.addEventListener('animationend', () => {
        confetti.remove();
      });
    }
  };

  // LLM Translation Function
  const translateText = useCallback(async (content, targetLanguage) => {
    if (targetLanguage === 'en') {
      return content; // No translation needed for English
    }

    setTranslationLoading(true);
    let prompt;
    let responseSchema;

    // Handle string content (e.g., individual recipe parts)
    if (typeof content === 'string') {
      prompt = `Translate the following text into ${targetLanguage}. Provide only the translated text as a string, no other formatting or explanation.`;
      responseSchema = { type: "STRING" };
      content = { text: content }; // Wrap string in an object for consistent processing
    } else {
      // Handle object content (e.g., full recipe object)
      prompt = `Translate the following JSON object's string values into ${targetLanguage}. Ensure the output is a valid JSON object with the same keys. Do not include any other text or formatting outside the JSON.`;
      responseSchema = {
        type: "OBJECT",
        properties: {
          name: { type: "STRING" },
          description: { type: "STRING" },
          ingredients: { type: "ARRAY", items: { type: "STRING" } },
          procedure: { type: "ARRAY", items: { type: "STRING" } }
        }
      };
    }

    const chatHistory = [{ role: "user", parts: [{ text: `${prompt}\n\nOriginal: ${JSON.stringify(content)}` }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setTranslationLoading(false);
          return parsedResult;
        } catch (parseError) {
          console.error("Error parsing LLM response JSON:", parseError, "Raw text:", text);
          setTranslationLoading(false);
          return typeof content === 'string' ? content : content; // Return original content on JSON parse failure
        }
      } else {
        console.error("LLM translation failed: No candidates or content found.", result);
        setTranslationLoading(false);
        return typeof content === 'string' ? content : content; // Return original content on no candidates
      }
    } catch (llmError) {
      console.error("Error calling LLM for translation:", llmError);
      setTranslationLoading(false);
      return typeof content === 'string' ? content : content; // Return original content on fetch error
    }
  }, []);

  // LLM: Ingredient Substitution
  const handleIngredientSubstitution = async (ingredientName) => {
    setLlmLoading(true);
    setSubstitutionResult(null);
    setSubstitutingIngredient(ingredientName);

    const prompt = `What are some good substitutions for "${ingredientName}" in a recipe? Provide 2-3 common alternatives and a brief note on their use. Format as a JSON object with a 'substitutions' array, where each item is an object with 'name' and 'note' properties.`;
    const responseSchema = {
      type: "OBJECT",
      properties: {
        substitutions: {
          type: "ARRAY",
          items: {
            type: "OBJECT",
            properties: {
              name: { type: "STRING" },
              note: { type: "STRING" }
            }
          }
        }
      }
    };

    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setSubstitutionResult(parsedResult.substitutions || []);
        } catch (parseError) {
          console.error("Error parsing LLM substitution response JSON:", parseError, "Raw text:", text);
          setSubstitutionResult([{ name: "Error", note: "Could not parse substitution suggestions." }]);
        }
      } else {
        console.error("LLM substitution failed: No candidates or content found.", result);
        setSubstitutionResult([{ name: "No suggestions", note: "Could not find substitutions." }]);
      }
    } catch (llmError) {
      console.error("Error calling LLM for substitution:", llmError);
      setSubstitutionResult([{ name: "Error", note: "Failed to fetch substitutions." }]);
    } finally {
      setLlmLoading(false);
      setShowSubstitutionModal(true);
    }
  };

  // LLM: Generate Creative Recipe Idea
  const handleGenerateCreativeRecipeIdea = async () => {
    setLlmLoading(true);
    setCreativeRecipeIdea(null);
    setApiError(null); // Clear any previous API errors

    if (userIngredients.length === 0) {
      setApiError(getTranslatedText("pleaseAddIngredient"));
      setLlmLoading(false);
      return;
    }

    const ingredientsList = userIngredients.join(', ');
    const prompt = `Given the following ingredients: ${ingredientsList}, suggest a creative and unique recipe idea. Provide the recipe name, a brief description (3-5 sentences), a list of key ingredients (max 5), and a short, simple procedure (3-5 steps). Format as a JSON object with keys 'name' (string), 'description' (string), 'keyIngredients' (array of strings), and 'shortProcedure' (array of strings).`;
    const responseSchema = {
      type: "OBJECT",
      properties: {
        name: { type: "STRING" },
        description: { type: "STRING" },
        keyIngredients: { type: "ARRAY", items: { type: "STRING" } },
        shortProcedure: { type: "ARRAY", items: { type: "STRING" } }
      }
    };

    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
    const payload = {
      contents: chatHistory,
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    };

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        try {
          const parsedResult = JSON.parse(text);
          setCreativeRecipeIdea(parsedResult);
        } catch (parseError) {
          console.error("Error parsing LLM creative idea response JSON:", parseError, "Raw text:", text);
          setCreativeRecipeIdea({ name: "Error", description: "Could not generate a creative idea.", keyIngredients: [], shortProcedure: [] });
        }
      } else {
        console.error("LLM creative idea failed: No candidates or content found.", result);
        setCreativeRecipeIdea({ name: "No Idea", description: "Could not generate a creative idea based on your ingredients.", keyIngredients: [], shortProcedure: [] });
      }
    } catch (llmError) {
      console.error("Error calling LLM for creative idea:", llmError);
      setCreativeRecipeIdea({ name: "Error", description: "Failed to generate a creative idea.", keyIngredients: [], shortProcedure: [] });
    } finally {
      setLlmLoading(false);
      setShowCreativeRecipeModal(true);
    }
  };


  // Auth Handlers
  const handleLogin = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      await signInWithEmailAndPassword(authInstance, email, password);
    } catch (error) {
      console.error("Login failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  const handleSignup = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      const userCredential = await createUserWithEmailAndPassword(authInstance, email, password);
      const user = userCredential.user;

      if (dbInstance) {
          await setDoc(doc(dbInstance, "users", user.uid), {
              email: user.email,
              userIngredients: [],
              savedRecipeIds: [],
              preferences: { cuisine: '', language: language }, // Default to Any Cuisine
              createdAt: new Date()
          });
          console.log("New user document created in Firestore.");
      }
    } catch (error) {
      console.error("Signup failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(authInstance, provider);
      const user = result.user;

      // Check if user data exists in Firestore, if not, create it
      if (dbInstance) {
        const userDocRef = doc(dbInstance, "users", user.uid);
        const userDocSnap = await getDoc(userDocRef);

        if (!userDocSnap.exists()) {
          await setDoc(userDocRef, {
            email: user.email,
            userIngredients: [],
            savedRecipeIds: [],
            preferences: { cuisine: '', language: language }, // Default to Any Cuisine
            createdAt: new Date()
          });
          console.log("New user document created in Firestore for Google login.");
        } else {
          console.log("Existing user document found for Google login.");
        }
      }
    } catch (error) {
      console.error("Google login failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };


  const handleSendOtp = async () => {
    setAuthLoading(true);
    setAuthError(null);
    if (!phoneNumber) {
      setAuthError(getTranslatedText("enterPhoneNumber"));
      setAuthLoading(false);
      return;
    }
    if (!recaptchaVerifier) {
      setAuthError(getTranslatedText("securityCheckNotReady"));
      setAuthLoading(false);
      return;
    }
    if (!authInstance) {
      setAuthError(getTranslatedText("firebaseAuthNotInitialized"));
      setAuthLoading(false);
      return;
    }

    try {
      const result = await signInWithPhoneNumber(authInstance, phoneNumber, recaptchaVerifier);
      setConfirmationResult(result);
      setAuthError(null);
      setShowOtpSentMessage(true);
      setTimeout(() => setShowOtpSentMessage(false), 3000); // Hide after 3 seconds
    } catch (error) {
      console.error("Error sending OTP:", error);
      setAuthError(error.message);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } finally {
      setAuthLoading(false);
    }
  };

  const handleVerifyOtp = async () => {
    setAuthLoading(true);
    setAuthError(null);
    if (!confirmationResult) {
      setAuthError(getTranslatedText("pleaseSendOtpFirst"));
      setAuthLoading(false);
      return;
    }
    if (!verificationCode) {
      setAuthError(getTranslatedText("enterVerificationCodeError")); // Corrected key
      setAuthLoading(false);
      return;
    }

    try {
      await confirmationResult.confirm(verificationCode);
      setAuthError(null);
      setPhoneNumber('');
      setVerificationCode('');
      setConfirmationResult(null);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } catch (error) {
      console.error("Error verifying OTP:", error);
      setAuthError(error.message);
      if (recaptchaVerifier && recaptchaVerifier.reset) {
        recaptchaVerifier.reset();
      }
    } finally {
      setAuthLoading(false);
    }
  };

  const handleLogout = async () => {
    setAuthLoading(true);
    setAuthError(null);
    try {
      if (!authInstance) throw new Error(getTranslatedText("firebaseAuthNotInitialized"));
      await signOut(authInstance);
    } catch (error) {
      console.error("Logout failed:", error);
      setAuthError(error.message);
    } finally {
      setAuthLoading(false);
    }
  };

  // Recipe App Handlers
  const handleAddIngredient = async () => {
    const trimmedInput = ingredientsInput.trim();
    if (trimmedInput && !userIngredients.includes(trimmedInput.toLowerCase())) {
      const newIngredient = trimmedInput.toLowerCase();
      const updatedIngredients = [...userIngredients, newIngredient];

      setUserIngredients(updatedIngredients);
      setIngredientsInput('');

      if (currentUser && dbInstance) {
          const userDocRef = doc(dbInstance, "users", currentUser.uid);
          try {
              await updateDoc(userDocRef, {
                  userIngredients: arrayUnion(newIngredient)
              });
              console.log("Ingredient saved to Firestore successfully!");
          } catch (error) {
              console.error("Error saving ingredient to Firestore:", error);
              alert(getTranslatedText("failedToSaveIngredient"));
              setUserIngredients(userIngredients);
          }
      } else {
          console.warn("Not logged in or Firestore not initialized, cannot save ingredient to cloud.");
      }
    }
  };

  const handleRemoveIngredient = async (ingredientToRemove) => {
    const updatedIngredients = userIngredients.filter(ing => ing !== ingredientToRemove);
    setUserIngredients(updatedIngredients);

    if (currentUser && dbInstance) {
        const userDocRef = doc(dbInstance, "users", currentUser.uid);
        try {
            await updateDoc(userDocRef, {
                userIngredients: arrayRemove(ingredientToRemove)
            });
            console.log("Ingredient removed from Firestore successfully!");
        } catch (error) {
            console.error("Error removing ingredient from Firestore:", error);
            alert(getTranslatedText("failedToRemoveIngredient"));
            setUserIngredients(userIngredients);
        }
    } else {
        console.warn("Not logged in or Firestore not initialized, cannot remove ingredient from cloud.");
    }
  };

  const handleClearAllIngredients = async () => {
    setUserIngredients([]);

    if (currentUser && dbInstance) {
        const userDocRef = doc(dbInstance, "users", currentUser.uid);
        try {
            await updateDoc(userDocRef, {
                userIngredients: []
            });
            console.log("All ingredients cleared in Firestore!");
        } catch (error) {
            console.error("Error clearing ingredients in Firestore:", error);
            alert(getTranslatedText("failedToClearIngredients"));
        }
    } else {
        console.warn("Not logged in or Firestore not initialized, cannot clear ingredients in cloud.");
    }
  };

  const fetchRecipes = async (type = 'ingredients') => {
    setLoading(true);
    setRecommendedRecipes([]);
    setApiError(null);
    setTranslationLoading(false); // Reset translation loading for new fetch

    let apiUrl = '';
    const baseUrl = 'https://api.spoonacular.com/recipes/';
    // addRecipeInformation and fillIngredients are useful for getting full details directly
    const commonParams = `number=15&apiKey=${SPOONACULAR_API_KEY}&addRecipeInformation=true&fillIngredients=true`;

    try {
        if (type === 'ingredients') {
            if (userIngredients.length === 0) {
                setLoading(false);
                setApiError(getTranslatedText("pleaseAddIngredient"));
                return;
            }
            const ingredientsString = userIngredients.join(',');
            apiUrl = `${baseUrl}findByIngredients?ingredients=${ingredientsString}&${commonParams}`;
            if (selectedCuisine) {
                apiUrl += `&cuisine=${selectedCuisine}`;
            }
        } else if (type === 'random') { // This is for "View Popular Dishes"
            let queryParams = commonParams;
            if (userIngredients.length > 0 && selectedCuisine) {
                // If ingredients and cuisine are present, prioritize recipes using them within the cuisine, sorted by popularity
                queryParams += `&includeIngredients=${userIngredients.join(',')}`;
                queryParams += `&cuisine=${selectedCuisine}`;
                queryParams += `&sort=popularity`; // Sort by popularity
                apiUrl = `${baseUrl}complexSearch?${queryParams}`;
            } else if (userIngredients.length > 0) {
                // If only ingredients are present, find recipes by ingredients, ranked by matching ingredients
                apiUrl = `${baseUrl}findByIngredients?ingredients=${userIngredients.join(',')}&number=15&ranking=1&apiKey=${SPOONACULAR_API_KEY}`;
            } else if (selectedCuisine) {
                // If only cuisine is selected, get popular recipes for that cuisine
                queryParams += `&cuisine=${selectedCuisine}&sort=popularity`;
                apiUrl = `${baseUrl}complexSearch?${queryParams}`;
            } else {
                // If no ingredients or cuisine, get truly random popular recipes
                apiUrl = `${baseUrl}random?${commonParams}`;
            }
        }

        const response = await fetch(apiUrl);

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        let recipesToProcess = [];
        // Handle different API response structures: /random returns { recipes: [...] }, complexSearch and findByIngredients return [...]
        if (apiUrl.includes('random') && data.recipes) {
            recipesToProcess = data.recipes;
        } else if (Array.isArray(data.results)) { // For complexSearch
            recipesToProcess = data.results;
        } else if (Array.isArray(data)) { // For findByIngredients
            recipesToProcess = data;
        } else {
            console.error("Unexpected data format from Spoonacular API:", data);
            setApiError("Received unexpected data format from recipe API. Please try again.");
            setLoading(false);
            setTranslationLoading(false);
            return;
        }

        const detailedRecipesPromises = recipesToProcess.map(async (recipe) => {
            // Since addRecipeInformation=true is used, often full details are already present.
            // But sometimes, especially for findByIngredients, 'instructions' or 'summary' might still be missing.
            let detailData = recipe;

            // Fetch full details if critical fields are missing or if it's from findByIngredients (which might not always return full info)
            if (!detailData.instructions || !detailData.summary || !detailData.extendedIngredients) {
                try {
                    const detailResponse = await fetch(
                        `${baseUrl}${recipe.id}/information?includeNutrition=false&apiKey=${SPOONACULAR_API_KEY}`
                    );
                    if (!detailResponse.ok) {
                        const errorDetailData = await detailResponse.json();
                        console.error(`Error fetching details for recipe ${recipe.id}:`, errorDetailData.message || detailResponse.status);
                        return null;
                    }
                    detailData = await detailResponse.json();
                } catch (detailError) {
                    console.error(`Failed to fetch details for recipe ${recipe.id}:`, detailError);
                    return null;
                }
            }

            let procedureSteps = [getTranslatedText("noInstructions")];
            if (detailData.instructions) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(detailData.instructions, 'text/html');

                const listItems = Array.from(doc.querySelectorAll('ol li, ul li'));
                if (listItems.length > 0) {
                    procedureSteps = listItems.map(li => li.textContent.trim()).filter(step => step !== '');
                } else {
                    let rawText = '';
                    const paragraphs = Array.from(doc.querySelectorAll('p, div, span'));
                    if (paragraphs.length > 0) {
                      rawText = paragraphs.map(p => p.textContent.trim()).join('\n').trim();
                    } else {
                      rawText = doc.body.textContent.trim();
                    }


                    rawText = rawText.replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ');

                    if (rawText) {
                      let tempSteps = rawText.split(/(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|\!)\s+|\n\s*\n/).filter(step => step.trim() !== '');
                      if (tempSteps.length > 0) {
                        procedureSteps = tempSteps;
                      } else {
                        procedureSteps = [rawText];
                      }
                    }
                }
            }

            // Filter out "waste items/recipes" - simple heuristic: if procedure is too short or description is too generic
            if (procedureSteps.length < 2 || (detailData.summary && detailData.summary.length < 50)) {
                console.log(`Skipping recipe ${detailData.id} due to short procedure or generic description.`);
                return null;
            }

            // --- LLM Translation for dynamic content ---
            let translatedName = detailData.title;
            let translatedDescription = detailData.summary ? detailData.summary.replace(/<\/?[^>]+(>|$)/g, "").substring(0, 150) + '...' : getTranslatedText('noDescription');
            let translatedIngredients = detailData.extendedIngredients ? detailData.extendedIngredients.map(ing => ing.name.toLowerCase()) : [];
            let translatedProcedure = procedureSteps;

            if (language !== 'en') {
                try {
                    const llmResponse = await translateText({
                        name: detailData.title,
                        description: detailData.summary ? detailData.summary.replace(/<\/?[^>]+(>|$)/g, "").substring(0, 150) + '...' : getTranslatedText('noDescription'),
                        ingredients: detailData.extendedIngredients ? detailData.extendedIngredients.map(ing => ing.name.toLowerCase()) : [],
                        procedure: procedureSteps
                    }, language);

                    if (llmResponse) {
                        translatedName = llmResponse.name || translatedName;
                        translatedDescription = llmResponse.description || translatedDescription;
                        translatedIngredients = llmResponse.ingredients || translatedIngredients;
                        translatedProcedure = llmResponse.procedure || translatedProcedure;
                    }
                } catch (llmErr) {
                    console.error("Error during LLM translation for recipe details:", llmErr);
                    // Fallback to English if translation fails
                }
            }
            // --- End LLM Translation ---

            return {
                id: String(detailData.id),
                name: translatedName,
                image: detailData.image,
                ingredients: translatedIngredients,
                description: translatedDescription,
                procedure: translatedProcedure,
                isTranslated: language !== 'en' // Mark if it has been translated
            };
        });

        const detailedRecipes = (await Promise.all(detailedRecipesPromises)).filter(Boolean); // Filter out nulls

        setRecommendedRecipes(detailedRecipes);
        setCurrentScreen(SCREENS.RECIPE_LIST);
    } catch (error) {
        console.error("Error fetching recipes:", error);
        setApiError(`${getTranslatedText("failedToFetchRecipes")} ${error.message}.`);
    } finally {
        setLoading(false);
        setTranslationLoading(false);
    }
  };

  const viewRecipeDetails = async (recipe) => {
    // If the recipe is not yet translated to the current language, translate it now.
    // This typically happens if it's a pre-defined dish that wasn't translated on list render.
    if (language !== 'en' && !recipe.isTranslated && !translationLoading) {
      setTranslationLoading(true);
      try {
        const llmResponse = await translateText({
          name: recipe.name,
          description: recipe.description,
          ingredients: recipe.ingredients,
          procedure: recipe.procedure
        }, language);

        if (llmResponse) {
          setSelectedRecipe({
            ...recipe,
            name: llmResponse.name || recipe.name,
            description: llmResponse.description || recipe.description,
            ingredients: llmResponse.ingredients || recipe.ingredients,
            procedure: llmResponse.procedure || recipe.procedure,
            isTranslated: true // Mark as translated
          });
        } else {
          setSelectedRecipe(recipe); // Fallback to original
        }
      } catch (llmErr) {
        console.error("Error during LLM translation for recipe details:", llmErr);
        setSelectedRecipe(recipe); // Fallback to original
      } finally {
        setTranslationLoading(false);
      }
    } else {
      setSelectedRecipe(recipe);
    }
    setCurrentScreen(SCREENS.RECIPE_DETAIL);
  };

  const startProcedure = () => {
    setCurrentProcedureStep(0);
    setCurrentScreen(SCREENS.PROCEDURE);
    setStepOpacity(0);
    setTimeout(() => setStepOpacity(1), 100);
  };

  const nextStep = () => {
    if (selectedRecipe && selectedRecipe.procedure) { // Added check for selectedRecipe.procedure
      if (currentProcedureStep < selectedRecipe.procedure.length - 1) {
        setStepOpacity(0);
        setTimeout(() => {
          setCurrentProcedureStep(prev => prev + 1);
          setStepOpacity(1);
        }, 300);
      } else {
        setCurrentScreen(SCREENS.COMPLETED);
      }
    }
  };

  const prevStep = () => {
    if (selectedRecipe && selectedRecipe.procedure) { // Added check for selectedRecipe.procedure
      if (currentProcedureStep > 0) {
        setStepOpacity(0);
        setTimeout(() => {
          setCurrentProcedureStep(prev => prev - 1);
          setStepOpacity(1);
        }, 300);
      }
    }
  };

  const copyRecipeToClipboard = () => {
    if (selectedRecipe) {
      const recipeText = `${getTranslatedText("recipe")}: ${selectedRecipe.name}\n\n` +
                         `${getTranslatedText("description")}: ${selectedRecipe.description}\n\n` +
                         `${getTranslatedText("ingredients")}:\n${Array.isArray(selectedRecipe.ingredients) ? selectedRecipe.ingredients.map(ing => `- ${ing}`).join('\n') : ''}\n\n` +
                         `${getTranslatedText("cookingProcedure")}:\n${Array.isArray(selectedRecipe.procedure) ? selectedRecipe.procedure.map((step, index) => `${index + 1}. ${step}`).join('\n') : ''}\n\n` +
                         `Find more delicious recipes on our app!`;

      const textarea = document.createElement('textarea');
      textarea.value = recipeText;
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        setShowCopiedMessage(true);
        setTimeout(() => setShowCopiedMessage(false), 2000);
      } catch (err) {
        console.error('Failed to copy text: ', err);
      } finally {
        document.body.removeChild(textarea);
      }
    }
  };

  // MessageBox Component
  const MessageBox = ({ message, type, onClose }) => {
    if (!message) return null;
    const bgColor = type === 'error' ? 'bg-red-100' : 'bg-green-100';
    const textColor = type === 'error' ? 'text-red-700' : 'text-green-700';
    const borderColor = type === 'error' ? 'border-red-400' : 'border-green-400';

    return (
      <div className={`${bgColor} bg-opacity-80 border ${borderColor} ${textColor} px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70`} role="alert">
        <span className="block sm:inline">{message}</span>
        {onClose && (
          <span className="absolute top-0 bottom-0 right-0 px-4 py-3 cursor-pointer" onClick={onClose}>
            <svg className="fill-current h-6 w-6" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.103l-2.651 3.746a1.2 1.2 0 0 1-1.697-1.697l3.746-2.651-3.746-2.651a1.2 1.2 0 0 1 1.697-1.697L10 8.897l2.651-3.746a1.2 1.2 0 0 1 1.697 1.697L11.103 10l3.746 2.651a1.2 1.2 0 0 1 0 1.698z"/></svg>
          </span>
        )}
      </div>
    );
  };

  // Modal Component for LLM features
  const Modal = ({ title, children, onClose, isLoading }) => {
    if (!children && !isLoading) return null; // Only render if there's content or loading

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 animate-fadeIn">
        <div className="bg-white bg-opacity-90 backdrop-blur-md rounded-xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-70 w-full max-w-md relative">
          <h2 className="text-3xl font-bold text-gray-800 mb-4 text-center">{title}</h2>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center py-8">
              <div className="animate-spin rounded-full h-12 w-12 border-b-4 border-blue-500 mb-4"></div>
              <p className="text-lg text-gray-700">
                {title.includes(getTranslatedText("ingredientSubstitutions")) ? getTranslatedText("findingSubstitutions") : getTranslatedText("generatingIdea")}
              </p>
            </div>
          ) : (
            children
          )}
          <button
            className="absolute top-3 right-3 text-gray-600 hover:text-gray-900"
            onClick={onClose}
          >
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
    );
  };


  // --- UI Rendering based on currentScreen state ---

  // Login Screen
  const renderLoginScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("welcomeBack")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="email-input" className="sr-only">{getTranslatedText("email")}</label>
        <input
          id="email-input"
          type="email"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("email")}
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <label htmlFor="password-input" className="sr-only">{getTranslatedText("password")}</label>
        <input
          id="password-input"
          type="password"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-6 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("password")}
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          onKeyPress={(e) => { if (e.key === 'Enter') handleLogin(); }}
        />
        {authError && (
          <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
            <strong className="font-bold">{getTranslatedText("error")}</strong>
            <span className="block sm:inline"> {authError}</span>
          </div>
        )}
        <button
          className={`w-full bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-blue-400 border-opacity-70 mb-4 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleLogin}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("loginWithEmail")}</span>
          )}
        </button>
        <button
          className={`w-full bg-gradient-to-r from-red-600 to-orange-700 hover:from-red-700 hover:to-orange-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-red-400 border-opacity-70 mb-4 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleGoogleLogin}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("loginWithGoogle")}</span>
          )}
        </button>
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          {getTranslatedText("dontHaveAccount")}{' '}
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.SIGNUP)}
          >
            {getTranslatedText("signUp")}
          </button>
        </p>
        <p className="mt-4 text-center text-gray-700 text-base sm:text-lg">
          Or{' '}
          <button
            className="text-purple-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.PHONE_LOGIN)}
          >
            {getTranslatedText("loginWithPhone")}
          </button>
        </p>
      </div>
    </div>
  );

  // Signup Screen
  const renderSignupScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("createAccount")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="signup-email-input" className="sr-only">{getTranslatedText("email")}</label>
        <input
          id="signup-email-input"
          type="email"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={getTranslatedText("email")}
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <label htmlFor="signup-password-input" className="sr-only">{getTranslatedText("password")}</label>
        <input
          id="signup-password-input"
          type="password"
          className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-6 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
          placeholder={`${getTranslatedText("password")} (min 6 characters)`}
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          onKeyPress={(e) => { if (e.key === 'Enter') handleSignup(); }}
        />
        {authError && (
          <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
            <strong className="font-bold">{getTranslatedText("error")}</strong>
            <span className="block sm:inline"> {authError}</span>
          </div>
        )}
        <button
          className={`w-full bg-gradient-to-r from-green-600 to-emerald-700 hover:from-green-700 hover:to-emerald-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-green-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
          onClick={handleSignup}
          disabled={authLoading}
        >
          {authLoading ? (
            <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
          ) : (
            <span>{getTranslatedText("signUp")} with Email</span>
          )}
        </button>
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          {getTranslatedText("alreadyHaveAccount")}{' '}
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => setCurrentScreen(SCREENS.LOGIN)}
          >
            {getTranslatedText("loginWithEmail")}
          </button>
        </p>
      </div>
    </div>
  );

  // Phone Login Screen
  const renderPhoneLoginScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("loginWithPhone")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        {!confirmationResult ? (
          <>
            <label htmlFor="phone-number-input" className="sr-only">{getTranslatedText("enterPhoneNumber")}</label>
            <input
              id="phone-number-input"
              type="tel"
              className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
              placeholder={getTranslatedText("enterPhoneNumber")}
              value={phoneNumber}
              onChange={(e) => setPhoneNumber(e.target.value)}
            />
            {authError && (
              <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
                <strong className="font-bold">{getTranslatedText("error")}</strong>
                <span className="block sm:inline"> {authError}</span>
              </div>
            )}
            <button
              className={`w-full bg-gradient-to-r from-purple-600 to-pink-700 hover:from-purple-700 hover:to-pink-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={handleSendOtp}
              disabled={authLoading}
            >
              {authLoading ? (
                <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
              ) : (
                <span>{getTranslatedText("sendOtp")}</span>
              )}
            </button>
            <div id="recaptcha-container" ref={recaptchaRef} className="mt-4"></div>
            <MessageBox message={showOtpSentMessage ? getTranslatedText("otpSent") : ''} type="success" onClose={() => setShowOtpSentMessage(false)} />
          </>
        ) : (
          <>
            <label htmlFor="verification-code-input" className="sr-only">{getTranslatedText("enterVerificationCode")}</label>
            <input
              id="verification-code-input"
              type="text"
              className="w-full p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-inner focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
              placeholder={getTranslatedText("enterVerificationCode")}
              value={verificationCode}
              onChange={(e) => setVerificationCode(e.target.value)}
              onKeyPress={(e) => { if (e.key === 'Enter') handleVerifyOtp(); }}
            />
            {authError && (
              <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4 text-center shadow-lg border-opacity-70" role="alert">
                <strong className="font-bold">{getTranslatedText("error")}</strong>
                <span className="block sm:inline"> {authError}</span>
              </div>
            )}
            <button
              className={`w-full bg-gradient-to-r from-purple-600 to-pink-700 hover:from-purple-700 hover:to-pink-800 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${authLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={handleVerifyOtp}
              disabled={authLoading}
            >
              {authLoading ? (
                <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white mx-auto"></div>
              ) : (
                <span>{getTranslatedText("verifyOtp")}</span>
              )}
            </button>
          </>
        )}
        <p className="mt-6 text-center text-gray-700 text-base sm:text-lg">
          <button
            className="text-blue-700 font-semibold hover:underline transition-colors duration-200"
            onClick={() => {
                setCurrentScreen(SCREENS.LOGIN);
                setAuthError(null);
                setConfirmationResult(null);
                setPhoneNumber('');
                setVerificationCode('');
                if (recaptchaVerifier && recaptchaVerifier.reset) {
                  recaptchaVerifier.reset();
                }
            }}
          >
            {getTranslatedText("backToEmailLogin")}
          </button>
        </p>
      </div>
    </div>
  );


  // Home Screen
  const renderHomeScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="absolute top-4 right-4 flex space-x-2">
        <button
          className="bg-gray-700 hover:bg-gray-800 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => setCurrentScreen(SCREENS.SETTINGS)}
        >
          {getTranslatedText("settings")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-6 sm:mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("whatsInKitchen")}</h1>
      <label htmlFor="ingredient-input" className="sr-only">{getTranslatedText("enterIngredient")}</label>
      <input
        id="ingredient-input"
        type="text"
        className="w-full max-w-md p-3 sm:p-4 border-2 border-blue-300 rounded-xl mb-4 bg-white bg-opacity-40 backdrop-blur-lg text-lg sm:text-xl shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 placeholder-gray-700 placeholder-opacity-75 border-opacity-60"
        placeholder={getTranslatedText("enterIngredient")}
        value={ingredientsInput}
        onChange={(e) => setIngredientsInput(e.target.value)}
        onKeyPress={(e) => { if (e.key === 'Enter') handleAddIngredient(); }}
      />
      <button
        className="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 mb-6 text-lg sm:text-xl font-semibold border-2 border-green-400 border-opacity-70"
        onClick={handleAddIngredient}
      >
        {getTranslatedText("addIngredient")}
      </button>

      <div className="w-full max-w-lg mt-6 p-5 bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl border-2 border-blue-300 min-h-28 flex flex-col items-center justify-center shadow-2xl border-opacity-60">
        {userIngredients.length > 0 ? (
          <>
            <h2 className="text-xl sm:text-2xl font-bold mt-2 mb-4 text-gray-800">{getTranslatedText("yourIngredients")}</h2>
            <div className="flex flex-wrap justify-center gap-2 mt-2">
              {userIngredients.map((ingredient, index) => (
                <div key={index} className="flex items-center bg-cyan-600 bg-opacity-70 rounded-full py-2 px-4 shadow-md transition-all duration-200 transform hover:scale-105 border border-cyan-400 border-opacity-70 animate-bounce-in">
                  <span className="text-white text-base font-medium mr-2">{ingredient}</span>
                  <button className="text-white font-bold text-base leading-none ml-1 opacity-80 hover:opacity-100" onClick={() => handleRemoveIngredient(ingredient)}>
                    X
                  </button>
                </div>
              ))}
            </div>
            <button
              className="mt-6 bg-red-500 hover:bg-red-600 text-white py-2 px-5 rounded-lg shadow-md transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95"
              onClick={handleClearAllIngredients}
            >
              {getTranslatedText("clearAll")}
            </button>
          </>
        ) : (
          <p className="text-lg text-gray-700 text-center">{getTranslatedText("addSomeIngredients")}</p>
        )}
      </div>

      <div className="w-full max-w-md mt-6">
        <label htmlFor="cuisine-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("selectCuisine")}</label>
        <select
          id="cuisine-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60"
          value={selectedCuisine}
          onChange={(e) => setSelectedCuisine(e.target.value)}
        >
          <option value="">{getTranslatedText("anyCuisine")}</option>
          <option value="Indian">Indian</option>
          <option value="Italian">Italian</option>
          <option value="Mexican">Mexican</option>
          <option value="Chinese">Chinese</option>
          <option value="American">American</option>
          <option value="French">French</option>
          <option value="Japanese">Japanese</option>
          <option value="Mediterranean">Mediterranean</option>
          <option value="Thai">Thai</option>
        </select>
      </div>

      {apiError && (
        <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-6 w-full max-w-lg text-center shadow-lg border-opacity-70" role="alert">
          <strong className="font-bold">{getTranslatedText("error")}</strong>
          <span className="block sm:inline"> {apiError}</span>
        </div>
      )}

      <button
        className={`mt-8 bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 text-white py-3 px-10 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-blue-400 border-opacity-70 ${userIngredients.length === 0 || loading || translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={() => fetchRecipes('ingredients')}
        disabled={userIngredients.length === 0 || loading || translationLoading || llmLoading}
      >
        {loading && !translationLoading ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>{getTranslatedText("findRecipes")}</span>
        )}
      </button>

      <button
        className={`mt-4 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-teal-400 border-opacity-70 ${loading || translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={() => fetchRecipes('random')}
        disabled={loading || translationLoading || llmLoading}
      >
        {loading && !translationLoading ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>{getTranslatedText("viewPopularDishes")}</span>
        )}
      </button>

      <button
        className={`mt-4 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg sm:text-xl font-semibold border-2 border-purple-400 border-opacity-70 ${userIngredients.length === 0 || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
        onClick={handleGenerateCreativeRecipeIdea}
        disabled={userIngredients.length === 0 || llmLoading}
      >
        {llmLoading && showCreativeRecipeModal ? (
          <div className="animate-spin rounded-full h-7 w-7 border-b-2 border-white"></div>
        ) : (
          <span>‚ú® {getTranslatedText("generateCreativeIdea")} ‚ú®</span>
        )}
      </button>

      {showCreativeRecipeModal && (
        <Modal
          title={getTranslatedText("creativeRecipeIdea")}
          onClose={() => setShowCreativeRecipeModal(false)}
          isLoading={llmLoading}
        >
          {creativeRecipeIdea ? (
            <div className="text-left">
              <h3 className="font-bold text-2xl text-gray-800 mb-2">{getTranslatedText("recipeName")}: {creativeRecipeIdea.name}</h3>
              <p className="text-gray-700 text-lg mb-4">{creativeRecipeIdea.description}</p>
              <h4 className="font-semibold text-xl text-gray-800 mb-2">{getTranslatedText("keyIngredients")}:</h4>
              <ul className="list-disc list-inside text-gray-700 text-lg mb-4">
                {creativeRecipeIdea.keyIngredients && creativeRecipeIdea.keyIngredients.map((ing, idx) => (
                  <li key={idx}>{ing}</li>
                ))}
              </ul>
              <h4 className="font-semibold text-xl text-gray-800 mb-2">{getTranslatedText("shortProcedure")}:</h4>
              <ol className="list-decimal list-inside text-gray-700 text-lg">
                {creativeRecipeIdea.shortProcedure && creativeRecipeIdea.shortProcedure.map((step, idx) => (
                  <li key={idx}>{step}</li>
                ))}
              </ol>
            </div>
          ) : (
            <p className="text-gray-700 text-lg">{getTranslatedText("noIdeaGenerated")}</p>
          )}
        </Modal>
      )}
    </div>
  );

  // Recipe List Screen
  const renderRecipeListScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-4xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.HOME); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          &larr; {getTranslatedText("backToIngredients")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-gray-800 text-center drop-shadow-lg">{getTranslatedText("recommendedRecipes")}</h1>

      {loading || translationLoading ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl">
          <RecipeCardSkeleton /><RecipeCardSkeleton /><RecipeCardSkeleton />
          <RecipeCardSkeleton /><RecipeCardSkeleton /><RecipeCardSkeleton />
        </div>
      ) : apiError ? (
        <div className="bg-red-100 bg-opacity-80 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-6 w-full max-w-lg text-center shadow-lg border-opacity-70" role="alert">
          <strong className="font-bold">{getTranslatedText("error")}</strong>
          <span className="block sm:inline"> {apiError}</span>
        </div>
      ) : recommendedRecipes.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 w-full max-w-6xl">
          {recommendedRecipes.map(recipe => (
            <div
              key={recipe.id}
              className="bg-white bg-opacity-40 backdrop-blur-lg rounded-xl overflow-hidden cursor-pointer transform hover:scale-105 transition-all duration-300 shadow-xl border-2 border-gray-200 border-opacity-60 animate-bounce-in"
              onClick={() => viewRecipeDetails(recipe)}
            >
              <img src={recipe.image} alt={recipe.name} className="w-full h-56 object-cover" />
              <div className="p-5">
                <h3 className="font-bold text-2xl text-gray-800 mb-2">{recipe.name}</h3>
                <p className="text-gray-700 text-lg mb-3">{recipe.description}</p>
                <p className="text-gray-600 text-md">
                  <span className="font-semibold">{getTranslatedText("ingredients")}:</span> {Array.isArray(recipe.ingredients) ? recipe.ingredients.slice(0, 5).join(', ') : ''}{Array.isArray(recipe.ingredients) && recipe.ingredients.length > 5 ? '...' : ''}
                </p>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <p className="text-xl text-gray-700 text-center">{getTranslatedText("noRecipesFound")}</p>
      )}
    </div>
  );

  // Recipe Detail Screen
  const renderRecipeDetailScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-purple-200 via-pink-200 to-orange-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-3xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.RECIPE_LIST); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          &larr; {getTranslatedText("backToRecipes")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      {selectedRecipe && (
        <div className="bg-white bg-opacity-60 backdrop-blur-lg rounded-2xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-3xl">
          <h1 className="font-extrabold text-4xl sm:text-5xl text-center text-gray-800 mb-6 drop-shadow-lg">{selectedRecipe.name}</h1>
          <img src={selectedRecipe.image} alt={selectedRecipe.name} className="w-full h-80 object-cover rounded-xl mb-6 shadow-lg" />

          <h2 className="font-bold text-3xl text-gray-800 mb-4">{getTranslatedText("description")}</h2>
          <p className="text-gray-700 text-lg leading-relaxed mb-6">{selectedRecipe.description}</p>

          <h2 className="font-bold text-3xl text-gray-800 mb-4">{getTranslatedText("ingredients")}</h2>
          <ul className="list-disc list-inside text-gray-700 text-lg mb-8 space-y-2">
            {selectedRecipe?.ingredients?.map((ingredient, index) => ( // Added optional chaining
              <li key={index} className="flex justify-between items-center">
                <span>{ingredient}</span>
                <button
                  className={`ml-2 bg-blue-500 hover:bg-blue-600 text-white text-xs px-3 py-1 rounded-full shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95 ${llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
                  onClick={() => handleIngredientSubstitution(ingredient)}
                  disabled={llmLoading}
                >
                  ‚ú® {getTranslatedText("substitute")}
                </button>
              </li>
            ))}
          </ul>

          <div className="flex justify-center gap-4 mb-6">
            <button
              className={`bg-orange-500 hover:bg-orange-600 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-orange-400 border-opacity-70 ${translationLoading || llmLoading ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={startProcedure}
              disabled={translationLoading || llmLoading}
            >
              {getTranslatedText("startCookingProcedure")}
            </button>
            <button
              className="bg-cyan-600 hover:bg-cyan-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-cyan-400 border-opacity-70 relative"
              onClick={copyRecipeToClipboard}
            >
              {getTranslatedText("copyRecipe")}
              {showCopiedMessage && (
                <span className="absolute -top-8 left-1/2 -translate-x-1/2 bg-gray-800 text-white text-sm px-2 py-1 rounded-md animate-fadeIn whitespace-nowrap">{getTranslatedText("copied")}</span>
              )}
            </button>
          </div>
          {translationLoading && (
            <div className="text-center text-blue-700 font-semibold mt-4">
              <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500 inline-block mr-2"></div>
              {getTranslatedText("translatingContent")}...
            </div>
          )}
        </div>
      )}

      {showSubstitutionModal && (
        <Modal
          title={`${getTranslatedText("ingredientSubstitutions")} ${substitutingIngredient}`}
          onClose={() => setShowSubstitutionModal(false)}
          isLoading={llmLoading}
        >
          {substitutionResult && substitutionResult.length > 0 ? (
            <ul className="list-disc list-inside text-gray-700 text-lg space-y-2">
              {substitutionResult.map((sub, idx) => (
                <li key={idx}>
                  <span className="font-semibold">{sub.name}:</span> {sub.note}
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-gray-700 text-lg">{getTranslatedText("noSuggestionsFound")}</p>
          )}
        </Modal>
      )}
    </div>
  );

  // Procedure Screen
  const renderProcedureScreen = () => (
    <div className="flex flex-col items-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-green-200 via-teal-200 to-blue-200 font-inter text-gray-900 animate-fadeIn">
      <div className="flex justify-between items-center w-full max-w-3xl mb-8">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => { setCurrentScreen(SCREENS.RECIPE_DETAIL); setCurrentProcedureStep(0); }} // Reset step on back
        >
          &larr; {getTranslatedText("backToDetails")}
        </button>
        {currentUser && (
          <button
            className="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
            onClick={handleLogout}
            disabled={authLoading}
          >
            {getTranslatedText("logout")}
          </button>
        )}
      </div>
      {selectedRecipe && (
        <div className="bg-white bg-opacity-60 backdrop-blur-lg rounded-2xl p-6 sm:p-8 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-3xl">
          <h1 className="font-extrabold text-4xl sm:text-5xl text-center text-gray-800 mb-6 drop-shadow-lg">{getTranslatedText("cookingProcedure")}</h1>

          <div className="relative w-full h-64 sm:h-80 mb-6 bg-gray-100 rounded-xl flex items-center justify-center overflow-hidden shadow-inner">
            <CookingAnimation step={currentProcedureStep} />
            <div className="absolute top-4 right-4 bg-purple-500 text-white text-sm font-bold px-3 py-1 rounded-full shadow-md">
                {getTranslatedText("step")} {currentProcedureStep + 1} / {selectedRecipe?.procedure?.length || 0} {/* Added optional chaining */}
            </div>
          </div>

          <p
            className="text-gray-800 text-xl leading-relaxed mb-8 text-center px-4 sm:px-0 transition-opacity duration-300"
            style={{ opacity: stepOpacity }}
          >
            {selectedRecipe.procedure[currentProcedureStep]}
          </p>

          <div className="flex justify-between gap-4 mt-4">
            <button
              className={`bg-blue-600 hover:bg-blue-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-blue-400 border-opacity-70 ${currentProcedureStep === 0 ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={prevStep}
              disabled={currentProcedureStep === 0}
            >
              &larr; {getTranslatedText("previousStep")}
            </button>
            <button
              className="bg-green-600 hover:bg-green-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-green-400 border-opacity-70"
              onClick={nextStep}
            >
              {currentProcedureStep < (selectedRecipe?.procedure?.length || 0) - 1 ? `${getTranslatedText("nextStep")} \u2192` : getTranslatedText("finishCooking")} {/* Added optional chaining */}
            </button>
          </div>
        </div>
      )}
    </div>
  );

  // Completed Screen
  const renderCompletedScreen = () => (
    <div className="relative flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-pink-200 via-orange-200 to-yellow-200 font-inter text-gray-900 overflow-hidden">
      <div ref={confettiContainerRef} className="absolute inset-0 pointer-events-none z- confettibox"></div> {/* Confetti container */}
      <div className="bg-white bg-opacity-70 backdrop-blur-lg rounded-2xl p-8 sm:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 text-center w-full max-w-xl animate-bounce-in">
        <h1 className="font-extrabold text-5xl sm:text-6xl text-gray-800 mb-6 drop-shadow-lg">{getTranslatedText("congratulations")}</h1>
        <p className="text-xl sm:text-2xl text-gray-700 mb-8">{getTranslatedText("recipeCompleted")} <br /><span className="font-bold text-purple-700">{selectedRecipe?.name || getTranslatedText("yourDish")}</span></p>

        <button
          className="bg-indigo-600 hover:bg-indigo-700 text-white py-3 px-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 text-lg font-semibold border-2 border-indigo-400 border-opacity-70 mb-4"
          onClick={() => { setCurrentScreen(SCREENS.HOME); setSelectedRecipe(null); }} // Clear selectedRecipe
        >
          {getTranslatedText("cookAnotherRecipe")}
        </button>
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-5 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold mt-2"
          onClick={handleLogout}
          disabled={authLoading}
        >
          {getTranslatedText("logout")}
        </button>
      </div>
    </div>
  );

  // Settings Screen
  const renderSettingsScreen = () => (
    <div className="flex flex-col items-center justify-center p-4 sm:p-6 md:p-8 min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200 font-inter text-gray-900 animate-fadeIn">
      <div className="absolute top-4 left-4">
        <button
          className="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out text-sm font-semibold transform hover:scale-105"
          onClick={() => setCurrentScreen(SCREENS.HOME)}
        >
          &larr; {getTranslatedText("backToHome")}
        </button>
      </div>
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-8 text-center drop-shadow-lg text-gray-800">{getTranslatedText("settings")}</h1>
      <div className="bg-white bg-opacity-40 backdrop-blur-lg rounded-2xl p-6 sm:p-8 md:p-10 shadow-2xl border-2 border-gray-200 border-opacity-60 w-full max-w-md">
        <label htmlFor="language-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("language")}:</label>
        <select
          id="language-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60 mb-6"
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
        >
          <option value="en">English</option>
          <option value="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä (Hindi)</option>
          <option value="kn">‡≤ï‡≤®‡≥ç‡≤®‡≤° (Kannada)</option>
          <option value="ta">‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç (Tamil)</option>
          <option value="ml">‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç (Malayalam)</option>
          <option value="te">‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å (Telugu)</option>
        </select>

        <label htmlFor="default-cuisine-select" className="block text-lg font-semibold text-gray-800 mb-2 text-center">{getTranslatedText("defaultCuisine")}:</label>
        <select
          id="default-cuisine-select"
          className="w-full p-3 border-2 border-blue-300 rounded-xl bg-white bg-opacity-40 backdrop-blur-lg text-lg shadow-xl focus:outline-none focus:ring-4 focus:ring-blue-400 transition-all duration-300 border-opacity-60"
          value={selectedCuisine}
          onChange={(e) => setSelectedCuisine(e.target.value)} // Update selectedCuisine directly
        >
          <option value="">{getTranslatedText("anyCuisine")}</option>
          <option value="Indian">Indian</option>
          <option value="Italian">Italian</option>
          <option value="Mexican">Mexican</option>
          <option value="Chinese">Chinese</option>
          <option value="American">American</option>
          <option value="French">French</option>
          <option value="Japanese">Japanese</option>
          <option value="Mediterranean">Mediterranean</option>
          <option value="Thai">Thai</option>
        </select>
      </div>
    </div>
  );


  // Render the appropriate screen based on currentScreen state
  const renderScreen = () => {
    if (authLoading) {
      return (
        <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-blue-200 via-purple-200 to-pink-200">
          <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
          <p className="ml-4 text-xl text-gray-700">{getTranslatedText("loadingApp")}</p>
        </div>
      );
    }

    if (!currentUser) {
      switch (currentScreen) {
        case SCREENS.SIGNUP:
          return renderSignupScreen();
        case SCREENS.PHONE_LOGIN:
          return renderPhoneLoginScreen();
        case SCREENS.LOGIN:
        default:
          return renderLoginScreen();
      }
    }

    switch (currentScreen) {
      case SCREENS.HOME:
        return renderHomeScreen();
      case SCREENS.RECIPE_LIST:
        return renderRecipeListScreen();
      case SCREENS.RECIPE_DETAIL:
        return renderRecipeDetailScreen();
      case SCREENS.PROCEDURE:
        return renderProcedureScreen();
      case SCREENS.COMPLETED:
        return renderCompletedScreen();
      case SCREENS.SETTINGS:
        return renderSettingsScreen();
      default:
        return renderHomeScreen();
    }
  };

  return (
    <>
      <style>{customAnimationsCss}</style>
      {renderScreen()}
    </>
  );
};

export default App;
